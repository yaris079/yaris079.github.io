[{"title":"Using the AXI DMA in Vivado","date":"2018-07-24T01:13:19.000Z","path":"2018/07/24/Using-the-AXI-DMA-in-Vivado/","text":"此文是转载自 http://www.fpgadeveloper.com/2014/08/using-the-axi-dma-in-vivado.html 我在测试AXI DMA时参考了这个文章，调通了xilinx官方的axidmatest.c 环境：uboot：2015.4 kernel 2015.3 vivado 2015.4.1修改的地方： 1、用SDK生成设备树要添加axidmatest的节点： axidma-test{compatible = “xlnx,axi-dma-test-1.00.a”;dmas = &lt;&amp;axi_dma_0 0 &amp;axi_dma_0 1&gt;;dma-names = “axidma0”, “axidma1”;}; 这个在xilinx官方论坛上有个帖子有说明，在4.0内核此要这个。 2、在vivado中打开AXI DMA 的IP，修改width of Buffer Length Register 修改为16（默认是14，我不知道这个有没有影响）。) 我在测试AXI DMA时参考了这个文章，调通了xilinx官方的axidmatest.c 环境：uboot：2015.4 kernel 2015.3 vivado 2015.4.1 修改的地方： 1、用SDK生成设备树要添加axidmatest的节点： axidma-test{compatible = “xlnx,axi-dma-test-1.00.a”;dmas = &lt;&amp;axi_dma_0 0 &amp;axi_dma_0 1&gt;;dma-names = “axidma0”, “axidma1”;}; 这个在xilinx官方论坛上有个帖子有说明，在4.0内核此要这个。 2、在vivado中打开AXI DMA 的IP，修改width of Buffer Length Register 修改为16（默认是14，我不知道这个有没有影响）。 以下是原文在之前的教程中，我介绍了如何在EDK中使用AXI DMA引擎，现在我将向您展示如何在Vivado中使用AXI DMA。我们将在Vivado中创建硬件设计，然后在Xilinx SDK中编写软件应用程序并在MicroZed板上进行测试（源代码在Github上用于MicroZed和ZedBoard，请参见底部的链接）。 什么是DMA？DMA代表直接内存访问，DMA引擎允许您将数据从系统的一部分传输到另一部分。DMA的最简单用法是将数据从存储器的一部分传输到另一部分，然而DMA引擎可用于将数据从任何数据产生器（例如ADC）传输到存储器，或从存储器传输到任何数据。数据消费者（例如DAC）。 教程概述在此设计中，我们将使用DMA将数据从内存传输到IP块并返回到内存。原则上，IP块可以是任何类型的数据生成器/消费者，例如ADC/DAC FMC，但在本教程中，我们将使用简单的FIFO来创建环回。之后，您将能够打破循环并插入您喜欢的任何自定义IP。上面的框图说明了我们将创建的设计。处理器和DDR内存控制器包含在Zynq PS中。AXI DMA和AXI数据FIFO在Zynq PL中实现。AXI-lite总线允许处理器与AXI DMA通信，以设置，启动和监控数据传输。AXI_MM2S和AXI_S2MM是存储器映射的AXI4总线，提供对DDR存储器的DMA访问。AXIS_MM2S和AXIS_S2MM是AXI4流式总线，可以连接和接收连续的数据流，无需地址。 笔记： MM2S代表Memory-Mapped to Streaming，而S2MM代表Streaming to Memory-Mapped。 使用Scatter-Gather时，DMA和内存控制器之间有一条额外的AXI总线。为简单起见，它被排除在图表之外。 要求在学习本教程之前，您需要执行以下操作： Vivado指令是为2014.2版编写的，但源代码将保留为最新版本 MicroZed 平台电缆USB II（或等效的JTAG编程器） 从基础项目开始我们将使用MicroZed的基本系统项目开始本教程，您可以在此处访问： MicroZed的基础系统项目 添加AXI DMA1.在Vivado中打开基础项目。2.在Flow Navigator中，单击”Open Block Design”。3.程序框图应该打开，你应该只在设计中使用Zynq PS。4.单击”添加IP”图标，然后双击目录中的”AXI直接内存访问”。 连接内存映射的AXI总线1.应该出现DMA块，并且应该提供设计人员帮助。单击”运行连接自动化”链接，然后从下拉菜单中选择”/axi_dma_0/S_AXI_LITE”。2.在出现的窗口中单击”确定”。Vivado将DMA的AXI-lite总线连接到PS的通用AXI互连。3.您的程序框图现在应如下所示：4.现在我们需要将DMA的AXI总线M_AXI_SG，M_AXI_MM2S和M_AXI_S2MM连接到PS上的高性能AXI从接口。我们的PS似乎没有高性能AXI从站接口，因此我们需要更改Zynq配置以启用它。双击Zynq块。5.选择”PS-PL Configuration”，打开”HP Slave AXI Interface”分支并勾选”S AXI HP0接口”以启用它。然后单击确定。6.现在，应在程序框图中显示高性能AXI从端口，并且应提供设计人员协助。单击”运行连接自动化”链接，然后从下拉菜单中选择”/processing_system7_0/S_AXI_HP0”。7.在出现的窗口中，确保Vivado打算将其连接到DMA并单击”确定”。8.再次提供Designer帮助，单击”运行连接自动化”链接，然后从下拉菜单中选择”/axi_dma_0/M_AXI_SG”。9.在出现的窗口中，单击”确定”。10.设计器帮助仍然可用，单击”运行连接自动化”链接并从下拉菜单中选择”/axi_dma_0/M_AXI_S2MM”。11.在出现的窗口中，单击”确定”。 现在所有内存映射的AXI总线都连接到DMA。现在我们只需要将AXI流总线连接到我们的环回FIFO并连接DMA中断。 添加FIFO1.单击”添加IP”图标，然后双击目录中的”AXI4-Stream Data FIFO”。FIFO应在程序框图中可见。现在我们必须将AXI流式总线连接到DMA的总线。单击FIFO上的”S_AXIS”端口并将其连接到DMA的”M_AXIS_MM2S”端口。然后连接FIFO上的’M_AXIS’端口并将其连接到DMA的’S_AXIS_S2MM’端口。现在我们必须连接FIFO时钟和复位。单击FIFO的’s_axis_aresetn’端口并将其连接到DMA的’axi_resetn’端口。单击FIFO的’s_axis_aclk’端口并将其连接到DMA的’s_axi_lite_aclk’端口。 删除DMA的AXI-Streaming状态和控制端口在我们的设计中，我们不需要AXI-Streaming状态和控制端口，用于在数据流旁边传输额外信息。如果您连接到AXI以太网核心或使用它们的自定义IP，您可以使用它们。 1.在程序框图中，双击AXI DMA块。2.取消选中”启用控制/状态流”选项，然后单击”确定”。 将DMA中断连接到PS我们的软件应用程序将在轮询模式下测试DMA，但为了能够在中断模式下使用它，我们需要将中断’mm2s_introut’和’s2mm_introut’连接到Zynq PS。 1.首先，我们必须启用PL的中断。双击Zynq块并选择Interrupts选项卡。2.勾选’Fabric Interrupts’和’IRQ_F2P [15：0]’以启用它们，然后单击OK。3.单击”添加IP”图标，然后双击目录中的”Concat”。4.将Concat的’dout’端口连接到Zynq PS的’IRQ_F2P’端口。5.将DMA的’mm2s_introut’端口连接到Concat的’In0’端口。6.将DMA的’s2mm_introut’端口连接到Concat的’In1’端口。 验证并构建设计1.从菜单中选择Tools-&gt;Validate Design。2.您应该收到此消息说验证成功。3.我们可以通过单击”Regenerate Layout icon”图标来清理程序框图。4.我们的框图现在看起来像这样：5.在Flow Navigator中，单击”Generate Bitstream”。 将硬件设计导出到SDK生成比特流后，我们可以将设计导出到SDK，我们可以开发软件应用程序，设置DMA传输，等待完成，然后验证环回。 1.在Vivado中，从”File”菜单中选择”Export-&gt;Export hardware”。2.在出现的窗口中，勾选”Include bitstream”并单击”OK”。3.再次从”File”菜单中选择”启动SDK”。4.在出现的窗口中，使用以下设置并单击”OK”。5.此时，SDK将加载并为您的设计创建硬件平台规范。您应该能够在SDK的Project Explorer中看到硬件规范，如下图所示。 我们现在准备创建软件应用程序。 创建软件应用程序此时，您的SDK窗口应该看起来像这样： 为了方便我们，我们将使用hello world应用程序的模板，然后修改它以测试AXI DMA。 1.从File菜单中，选择New-&gt;Application Project。2.在”新建项目”向导的第一页中，选择应用程序的名称。我选择了”hello_world”。点击下一步”。3.在模板页面上，选择”Hello World”模板，然后单击”完成”。4.SDK将生成一个新的应用程序，您可以在Project Explorer中找到该应用程序，如下图所示。“hello_world”文件夹包含Hello World软件应用程序，我们将对其进行修改以测试我们的AXI DMA。 ####修改软件应用程序我们需要修改hello world软件应用程序来测试我们的DMA。 从Project Explorer中，打开”hello_world/src”文件夹。打开”helloworld.c”源文件。使用您在此处找到的代码替换此文件中的所有代码：C:\\Xilinx\\SDK(version)\\data\\embeddedsw\\XilinxProcessorIPLib\\drivers\\axidma_v(ver)\\examples\\xaxidma_example_sg_poll.c保存并关闭文件。应用程序应自动构建。我们在本教程中使用的应用程序源代码是Xilinx在安装文件中提供的许多有价值的示例之一。如果您不了解这些示例，我建议您每次开始使用新IP核时都要查看。 在硬件上测试设计为了测试设计，我们使用了Avnet的MicroZed板。在继续之前进行以下设置： 1.在MicroZed上，将JP1，JP2和JP3跳线全部设置为1-2位置。2.将USB-UART（J2）连接到PC的USB端口。3.将平台电缆USB II编程器（或类似设备）连接到JTAG连接器。将编程器连接到PC的USB端口。 现在，您需要在PC上打开终端程序并将其设置为接收测试消息。我使用Miniterm因为我是Python粉丝，但你可以使用任何其他终端程序，如Putty。使用以下设置： Comport - 检查您的设备管理器以找出MicroZed弹出的内容。就我而言，它是COM12，如下所示。 Baud rate：115200bps Data：8 bits Parity: None Stop bits: 1现在您的PC已准备好接收测试消息，我们已准备好将我们的比特流和软件应用程序发送到硬件。 1.在SDK中，从菜单中选择Xilinx Tools-&gt;Program FPGA。在Program FPGA窗口中，我们选择要编程的硬件平台。我们只有一个硬件平台，所以点击”Program”。比特流将加载到Zynq上，我们已准备好加载软件应用程序。在Project Explorer中选择”hello_world”文件夹，然后从菜单中选择Run-&gt;Run。在”运行方式”窗口中，选择”Launch on Hardware (GDB)”，然后单击”OK”。应用程序将加载到Zynq PS上，它将被执行。在终端窗口中查找结果！ 源代码该项目的TCL构建脚本和源代码在Github上通过以下链接共享： 对于MicroZed：https：//github.com/fpgadeveloper/microzed-axi-dma对于ZedBoard：https：//github.com/fpgadeveloper/zedboard-axi-dma有关从源重建项目的说明，请阅读我关于Vivado项目的版本控制的帖子。","tags":[{"name":"嵌入式arm","slug":"嵌入式arm","permalink":"https://yaris079.github.io/tags/嵌入式arm/"}]},{"title":"ZYNQ之uboot，kernel，设备树，文件系统生成","date":"2018-07-20T07:24:40.000Z","path":"2018/07/20/ZYNQ之uboot，kernel，设备树，文件系统生成/","text":"一、 交叉编译器：使用xilinx提供的编译器arm-xilinx-linux-gnueabi- Version 4.6.1版本。 1. 添加交叉编译器的环境变量：123export ARCH=armexport CROSS_COMPILE=arm-xilinx-linux-gnueabi-export PATH=/root/CodeSourcery/Sourcery_CodeBench_Lite_for_Xilinx_GNU_Linux/bin/:$PATH 2. 检验交叉编译器安装是否成功：在终端输入arm-xilinx-linux-gnueabi-gcc –v 查看版本号； 说明安装成功。 二、u-boot使用从xilinx的github仓库上下载的u-boot-xlnx-xilinx-v2015.4.zip版本。下载dtc编译器。https://git.kernel.org/pub/scm/utils/dtc/dtc.git参考xilinx的wiki http://www.wiki.xilinx.com/Fetch%20Sources 1.u-boot编译过程中需要用到dtc编译器，根据xilinx的wiki指导进行下载。1git clone https://git.kernel.org/pub/scm/utils/dtc/dtc.git 进入dtc目录，执行make命令12cd dtcmake 执行make指令之前请先将xillinx tools 添加至环境变量。xillinx tools在Xilinx SDK中。构建过程完成后，将在当前目录中创建dtc二进制文件。必须使工具可访问dtc二进制文件的路径（例如，U-Boot构建过程）。要在其他步骤中使用dtc，建议将tools目录添加到$PATH变量中。 这里还可以直接使用 apt-get install device-tree-compiler 安装dtc编译器，省去了自己下载源代码编译的麻烦。 2.配置u-boot将u-boot解压，并进入到解压目录下。12unzip u-boot-xlnx-xilinx-v2015.4.zipcd u-boot-xlnx-xilinx-v2015.4 将u-boot配置SDRAM大小为 512M大小，添加QSPI支持。1vim u-boot-xlnx-xilinx-v2015.4/include/configs/zynq_zed.h 添加以下宏，之后保存退出。 3.编译u-boot如果第一步配置好了环境变量，直接执行：123make distcleanmake zynq_zed_configmake 编译完成后，生成ELF格式的u-boot文件，将其重命名为”u-boot.elf”。并注意生成mkconfig可执行文件，制作文件系统时会用到。 编译U-boot时会遇到2个错误。原因很简单，就从一开始的错误提示着手： fatal error: openssl/evp.h: 没有那个文件或目录。当然在网上也可以搜索到相关的解决方法。在此仅作为记录：如果你在编译时遇到这个错误，这可能是下面的原因：你尝试编译的程序使用OpenSSL，但是需要和OpenSSL链接的文件（库和头文件）在你Linux平台上缺少,所以要自己安装相关的文件。 要在Ubuntu上安装OpenSSL：1$ sudo apt-get install libssl-dev 4.使用xilinx SDK 制作boot.bin在xilinx SDK中新建一个工程，使用 Zynq FSBL 模板，直接编译生成FSBL.elf。在SDK界面选择Xilinx Tools-&gt;Create Zynq Boot Image弹出上面对话框来生成boot文件。依次按顺序添加FSBL.elf、system.bit和u-boot.elf文件。System.bit是使用Vivado生成的比特流文件， u-boot.elf就是我们刚生成的文件。最后制定输出目录生成BOOT.BIN文件。 三、内核kernel编译Linux内核首先我们也要先下载源码并解压，设置交叉编译环境，导入内核配置，然后编译。内核文件linux-xlnx-xilinx-v2015.4.zip 也可以在xilinx的github仓库找到。编译后生成的文件为zImage，位于arch/arm/boot/目录下，这里我们需要制作未经压缩过的内核镜像uImage。编译uImage过程中需要用到mkimage，可以在uboot文件夹的tools目录下找到。1234unzip linux-xlnx-xilinx-v2015.4.zipmake xilinx_zynq_defconfigmakemake UIMAGE_LOADADDR=0x8000 uImage -j8 编译完成后，在 arch/arm/boot 下生成未经压缩过的内核镜像uImage,在arch/arm/boot/dts 目录下生成zynq-zed.dts设备树文件。 四、设备树文件使用编译kernel时候生成的zynq_zed.dts进行编译设备树文件 zynq_zed.dtb。 1. 配置dtc的环境变量在kernel/scripts/dtc/下有dtc命令文件，使用这个命令可以生成.dtb文件。打开~/.bashrc文件，在最后添加：（按实际情况添加具体路径）export PATH=$PATH:~/xillinx/linux-xlnx-xilinx-v2014.4/scripts/dtc 2. 按需要改写.dts文件devicetree的生成依赖于FPGA工程中ZYNQ的配置，方法请参考：http://blog.chinaaet.com/cuter521/p/5100001052 3. 生成.dtb文件在arch/arm/boot/dts目录下使用如下命令生成devicetree.dtb文件。1dtc -I dts -O dtb -o devicetree.dtb zynq-zed.dts 五、根文件系统1.解压压缩包。12gunzip arm_ramdisk.image.gzchmod u+rwx arm_ramdisk.image 2.创建目录并挂载ramdisk：12mkdir file_systemmount arm_ramdisk.image file_system 3.修改file_system内容，由于我们未使用到sd卡，因此将/etc/fstab中的最后两行删除掉。完成修改后卸载。1umount file_system 4.压缩文件系统。1gzip arm_ramdisk.image 5.生成uramdisk.image.gz文件。1mkimage -A arm -T ramdisk -C gzip -d arm_ramdisk.image.gz uramdisk.image.gz 六、 按照zynq_zed.dts中的分区，烧写BOOT.bin、devicrtree.dtb、uImage、ramdisk：1.首先使用SD卡启动，进入u-boot命令行； 2.开启TFTP服务器，使用tftp将BOOT.bin通过网络烧写道qspi的0x0地址：1234tftp 0x800000 BOOT.bin //加载到内存sf probe 0 0 0sf erase 0x0 0x100000 //擦除1M空间sf write 0x800000 0x0 0x100000 //写入qspi 3.烧写 uImage123tftp 0x800000 uImage sf erase 0x100000 0x600000sf write 0x800000 0x100000 0x600000 4.烧写 devicetree.dtb123tftp 0x800000sf erase 0x700000 0x100000sf write 0x800000 0x700000 0x100000 5.烧写 ramdisk123tftp 0x4000000 ramdisksf erase 800000 1200000sf write 0x4000000 800000 1200000 6.烧写 fpga生成的 xx.bit程序123tftp 0x4000000 xx.bitsf erase 1A00000 500000sf write 0x8000000 1A00000 500000 七、 设置u-boot参数及启动方式：将板卡启动方式改为qspi启动.进入u-boot命令行,输入命令：123setenv bootcmd 'sf probe 0 0 0 &amp;&amp; echo qspi-bitstream is loading ... ... &amp;&amp; sf read 0x800000 0x1A00000 0x500000 &amp;&amp; fpga loadb 0 0x800000 0x400000 &amp;&amp; echo uIamge is loading ... ... &amp;&amp; sf read 0x2080000 0x100000 0x600000 &amp;&amp;echo deviceTree is loading ... ... &amp;&amp; sf read 0x2000000 0x700000 0x100000 &amp;&amp; echo ramdisk.image is loading ... ... &amp;&amp; sf read 0x4000000 0x800000 0x1200000 &amp;&amp; bootm 0x2080000 0x4000000 0x2000000'saveenv 八、 重启板卡，顺利从qspi启动:","tags":[{"name":"嵌入式arm","slug":"嵌入式arm","permalink":"https://yaris079.github.io/tags/嵌入式arm/"}]},{"title":"qtopia的使用","date":"2018-05-25T21:42:39.000Z","path":"2018/05/26/qtopia的使用/","text":"一、qtopia的安装：前面我们已经编译好了arm版和PC版的qtopia2.2.0。进入qtopia-free-2.2.0，我们可以看到4个文件用于设置环境变量： setQpeEnv：QTOPIA用的！ setQteEnv：嵌入式开发用的声明文件； setDqtEnv setQt2Env 依次运行：1、虚拟窗口运行：$cd qtopia/bin$qvfb -width 640 -height 480&amp;$./qpe -qws 二、添加自己的程序到Qtopia:1、复制一个实例程序$cd somewhere$cp -r $QPEDIR/examples/application .$chmod +w application/*$cd application 2、生成 Makefile文件:$qmake -spec $QPEDIR/mkspecs/qws/linux-generic-g++ application.pro 3、 编译:$make 4、安装程序到qtopia：$make install INSTALL_ROOT=$QPEDIR 删除程序一定要在这个目录下$make uninstall INSTALL_ROOT=$QPEDIR 5.测试：$cd $QPEDIR/bin$qvfb &amp;$./example -qws我们会看到在Applications栏里出现了example，打开可以运行！ 注意：不过此时我们可以看到应用程序没有图标，我们可以将图标文件复制到$QPEDIR/image/opt/Qtopia/pic目录下，我们还可以自己再建个文件夹例如example把图标放在此目录下，系统会自动搜索的！ 三、编写自己的hello world!1、编译：进入qt2/tutorial（这是自带的一些教程源码）我们来个最简单的，复制t1文件夹，只留下main.cpp 就可以了，$qmake -project CONFIG+=qtopia TARGET=hello这样就生成了t1.pro工程文件，因为默认是没有config 和target 的，我们自己添上；哈哈$qmake -spec $QPEDIR/mkspecs/qws/linux-generic-g++ t1.pro这样就生成了Makefile文件；$make就生成了hello 2、测试：$qvfb &amp;$./hello -qws可以看到我们的hello world! 了。 四、自己使用designer来设计hello world！1、designer//启动qtopia自带的designer！设计界面，hello world!其中：窗体名为: Form1;保存文件，test/form.ui 打开designer后如果发现窗口都是透明的看不清楚内容，这是ubuntu开启了透明效果，可以# XLIB_SKIP_ARGB_VISUALS=1 designer,但关闭shell后重新打开又会这样。也可以在登陆时选择ubuntu 2D，或者编辑/etc/profie,加入export XLIB_SKIP_ARGB_VISUALS=1注销后重新登陆，这时ubuntu也关闭了透明效果。打开designer后选择file–&gt;new–&gt;widget新建一个窗体 2、编写main.cpp文件：123456789include include \"form.h\"int main(int argc, char *argv[])&#123;QApplication app(argc, argv);Form1 w;w.show();return app.exec();&#125; 3、生成工程文件：$qmake -project CONFIG+=qtopia TARGET=test 4、生成Makefile文件：$qmake -spec $QPEDIR/mkspecs/qws/linux-generic-g++ test.pro$make 5.测试：$qvfb &amp;$./test -qws 五、将自己写的hello world 放到qtopia系统下运行：1、编写test.desktop123456789[Translation]File=example-nctContext=test[Desktop Entry]Comment[]=An Example ProgramExec=testIcon=testType=ApplicationName[]=test 把test.desktop放在$QPEDIR/apps/Applications目录下 2、编辑图标文件，test.png把test.png放在$QPEDIR/pics目录下，也可以在此目录下建自己的目录。 3、测试：$cd $QPEDIR/bin$./test -qws可以看到我们的test程序","tags":[{"name":"arm嵌入式","slug":"arm嵌入式","permalink":"https://yaris079.github.io/tags/arm嵌入式/"}]},{"title":"qtopia2-2-0-pc在Ubuntu下的编译","date":"2018-05-25T12:43:21.000Z","path":"2018/05/25/qtopia2-2-0-pc在Ubuntu下的编译/","text":"下载所需的库文件apt-get install libx11-dev libxext-dev libxtst-devapt-get install uuid-devapt-get install libxmu-dev libxmu6apt-get install libwxgtk2.8-0 libwxgtk2.8-dev wx2.8-headers wx-commonapt-get install libsmbclient-devapt-get install libcupsys2-devapt-get install libopensc2-devapt-get install build-essentialapt-get install libx11-devapt-get install libxmu-devapt-get install libjpeg-devapt-get install libpng-devapt-get install zlib1g-devapt-get install lib32z1-devapt-get install bisonapt-get install flexapt-get install lib32ncurses5-devapt-get install libx11-devapt-get install gperf 注意！ 使用gcc编译qtopia2.2.0需要使用gcc4.4及以下版本gcc，g++改为高版本的随时用update-alternatives –config 命令切换！","tags":[{"name":"嵌入式arm","slug":"嵌入式arm","permalink":"https://yaris079.github.io/tags/嵌入式arm/"}]},{"title":"qtopia2.2.0-arm在Ubuntu下的编译","date":"2018-05-25T05:42:18.000Z","path":"2018/05/25/qtopia2-2-0-arm在Ubuntu下的编译/","text":"1.编译第三方库编译qtopia-free-forlinx-2.2.0 前确认已经把您刚 才制作的/root/yizhi/arminclude 下的文件放到交叉编译器目录 “arm-none-linux-gnueabi\\libc\\usr\\include” 里面，所有的库文件放到交叉编译器安装目录的“arm-none-linux-gnueabi\\libc\\usr\\lib” 文件夹下面 另外需要注意的是用官方提供的 Qtopia2.2.0 源代码编译出来的版本，主界面的图标下会出现一条虚线，影响美观，将ARM-qtopia-free-src-2.2.0.tar.gz解压到 /root/yizhi 文 件 夹 后（yizhi 是自己建立的文件夹），打开qtopia-free-2.2.0/qtopia/src/qt/qconfig-qpe.h 文件，在里面增加以下内容即可解决虚线的问题：1#define QT_NO_QWS_GFX_SPEED 修改脚本脚本里面有编译时需要的环境变量：gedit build 注意：编译过程中产生的状态信息将记录到当前目录下的 qtopia2.2.0Makelog 文件里面，如果编译过程中产生了大量的错误信息，打开该文件，查找 error 关键字进行问题的定位，里面记录的信息对您很有帮助，有时焦点不会停留在出现错误的位置，这时查看日志文件就很重要了。 2 常见bug2.1 open函数缺少必要的参数 错误信息：In function ‘int open(const char*, int, ...)’, inlined from ‘QMemoryFileData* QMemoryFile::openData(const QString&amp;, int, uint)’ at tools/qmemoryfile_unix.cpp:143:54: /usr/include/i386-linux-gnu/bits/fcntl2.h:51:26: error: call to ‘__open_missing_mode’ declared with attribute error: open with O_CREAT in second argument needs 3 arguments 修改： 文件路径：（此错误有两处） /root/yizhi/qtopia-free-2.2.0/qt2/src/tools/qmemoryfile_unix.cpp 找到：（143行） /root/yizhi/qtopia-free-2.2.0/qtopia/src/libraries/qtopia/qmemoryfile_unix.cpp 找到：（141行） 1f = ::open(tmpFile.latin1(), O_CREAT | O_WRONLY); 修改为：1f = ::open(tmpFile.latin1(), O_CREAT | O_WRONLY, 0666); 2.2缺少头文件错误错误信息：../include/qmap.h:107:13: error: ‘ptrdiff_t’ does not name a type ../include/qmap.h:223:13: error: ‘ptrdiff_t’ does not name a type ../include/qvaluelist.h:88:13: error: ‘ptrdiff_t’ does not name a type ../include/qvaluelist.h:164:13: error: ‘ptrdiff_t’ does not name a type make[2]: *** [.obj/release-shared-mt/qapplication_x11.o] Error 1修改方法： 在qtopia-free-2.2.0/dqt/include的qvaluelist.h和qmap.h文件下增加两个头文件：12#include \"stddef.h\"#include &lt;cstddef&gt; 搜索文件命令: find –name “qmap.h” 2.3 使用未定义的类错误信息：/root/yizhi/qtopia-free-2.2.0/qt2/include/qwindowsystem_qws.h:230: error: &#39;QWSInputMethod&#39; has not been declared /root/yizhi/qtopia-free-2.2.0/qt2/include/qwindowsystem_qws.h:237: error: &#39;QWSGestureMethod&#39; has not been declared make[1]: *** [allmoc.o] Error 1修改：cd /root/yizhi/qtopia-free-2.2.0/qt2/src/kernelgedit qwindowsystem_qws.h在前面增加以下两行12class QWSInputMethod; class QWSGestureMethod; 保存退出，继续编译 2.4缺少uuid库Creating pngscale...make[1]: Entering directory /root/yizhi/qtopia-free-2.2.0/qtopia/util/pngscal .................................................................make[1]: *** [../../bin/pngscale] Error 1 make[1]: Leaving directory /root/yizhi/qtopia-free-2.2.0/qtopia/util/pngscal Failed to make pngscale修改方法：apt-get install uuid-dev 2.5缺少系统头文件错误信息：kernel/qpixmapcache.cpp:125: fatal error: asm/page.h: No such file or directory compilation terminated. make[1]: *** [tmp/release-shared-linux-arm-g++-no-keypad/kernel/qpixmapcache.o] Error 1 make[1]: Leaving directory /root/yizhi/qtopia-free-2.2.0/qt2/src&#39;修改：路径(两个地方)：/root/yizhi/qtopia-free-2.2.0/qt2/src/kernel/qpixmapcache.cpp 第125行./root/yizhi/qtopia-free-2.2.0/qt2/tools/qvfb/qvfbview.cpp 第39行修改为：1234#define PAGE_SHIFT 12#define PAGE_SIZE(1UL &lt;&lt; PAGE_SHIFT)#define PAGE_MASK(~(PAGE_SIZE-1))//#include//PAGE_SIZE,PAGE_MASK,PAGE_ALIGN 这样修改是因为新的 Linux 内核源代码中已经不包含该头文件了。 2.6 this指针错误信息：root/yizhi/qtopia-free-2.2.0/qt2/include/qvaluestack.h:57:6: error: cannot convert ‘QValueList&lt;qmap &gt;::Iterator {aka QValueListIterator&lt;qmap &gt;}&lt;/qmap&lt;/qmap’ to ‘const char*’ for argument ‘1’ to ‘int remove(const char*)’ /root/yizhi/qtopia-free-2.2.0/qt2/include/qvaluestack.h: In member function ‘T QValueStack::pop() [with T = QString]’: xml/qxml.cpp:2532:57: instantiated from here /root/yizhi/qtopia-free-2.2.0/qt2/include/qvaluestack.h:57:6: error: cannot convert ‘QValueList::Iterator {aka QValueListIterator}’ to ‘const char*’ for argument ‘1’ to ‘int remove(const char*)’ make[1]: *** [tmp/release-shared-linux-g++/xml/qxml.o] Error 1修改：路径:./root/yizhi/qtopia-free-2.2.0/qt2/src/include/qvaluestack.h(57行)将 remove( this-&gt;fromLast() );改为 this-&gt;remove( this-&gt;fromLast() );保存退出 2.7 缺少文件错误信息：../../../include/qtopia/custom-qtopia.h:1: fatal error: ../../src/libraries/qtopia/custom-linux-arm-g++.h: No such file or directory compilation terminated. make[5]: *** [.obj/release-shared/qpeapplication.o] Error 1修改：路径：/yizhi/qtopia-free-2.2.0/qtopia/src/libraries/qtopia进入该路径后执行以下命令：cp custom-linux-ipaq-g++.cpp custom-linux-arm-g++.cppcp custom-linux-ipaq-g++.h custom-linux-arm-g++.h 2.8一类出现较多的错误2.8.1错误信息： qdawg.cpp:294: error: extra qualification &#39;QDawgPrivate::&#39; on member &#39;QDawgPrivate&#39;修改：路径：./root/yizhi/qtopia-free-2.2.0/qtopia/src/libraries/qtopia/qdawg.cpp（294行）去掉’QDawgPrivate::’ 2.8.2错误信息：thumbnailview_p.h:81: error: extra qualification &#39;ThumbnailItem::&#39; on member &#39;paintItem&#39;修改：路径：/root/yizhi/qtopia-free-2.2.0/qtopia/src/libraries/qtopia2/thumbnailview_p.h（81行）去掉’ThumbnailItem::’ 2.8.3错误信息：abtable_p.h:276: error: extra qualification &#39;PhoneTypeSelector::&#39; on member &#39;addType&#39;修改：路径：/root/yizhi/qtopia-free-2.2.0/qtopia/src/libraries/qtopiapim/abtable_p.h（276行）去掉’PhoneTypeSelector::’ 2.8.4错误信息：numberentry_p.h:106: error: extra qualification &#39;NumberEntryDialog::&#39; on member &#39;eventFilter&#39;修改：路径/root/yizhi/qtopia-free-2.2.0/qtopia/src/libraries/qtopiapim/numberentry_p.h（106行）去掉’NumberEntryDialog::’ 2.8.5错误信息：videoviewer.cpp:52: error: extra qualification &#39;SimpleVideoWidget::&#39; on member &#39;SimpleVideoWidget&#39;修改：./root/yizhi/qtopia-free-2.2.0/qtopia/src/libraries/mediaplayer/videoviewer.cpp （52行）去掉’SimpleVideoWidget::’ 2.8.6错误信息：ablabel.h:78: error: extra qualification &#39;AbLabel::&#39; on member &#39;decodeHref&#39;修改：路径：/root/yizhi/qtopia-free-2.2.0/qtopia/src/applications/addressbook/ablabel.h（78行）去掉’AbLabel::’ 2.8.7错误信息：minefield.h:105: error: extra qualification &#39;MineField::&#39; on member &#39;setState&#39; minefield.h:106: error: extra qualification &#39;MineField::&#39; on member &#39;placeMines修改：路径：./root/yizhi/qtopia-free-2.2.0/qtopia/src/games/minesweep/minefield.h（105 106行）去掉’MineField::’ 2.8.8buttoneditordialog.h:56: error: extra qualification &#39;ButtonEditorDialog::&#39; on member &#39;actionFor&#39;修改：路径：./root/yizhi/qtopia-free-2.2.0/qtopia/src/settings/buttoneditor/buttoneditordialog.h（56行）去掉’ButtonEditorDialog::’ 2.8.9packagewizard.h:106: error: extra qualification &#39;PackageWizard::&#39; on member &#39;current&#39;修改：./root/yizhi/qtopia-free-2.2.0/qtopia/src/settings/qipkg/packagewizard.h（106行）去掉’PackageWizard::’ 2.8.10keyboard.h:60: error: extra qualification &#39;KeyboardPicks::&#39; on member &#39;KeyboardPicks&#39;修改：路径：./root/yizhi/qtopia-free-2.2.0/qtopia/src/plugins/inputmethods/keyboard/keyboard.h（60行）去掉~ KeyboardPicks前面的’KeyboardPicks::’ 2.8.11polished.h:58: error: extra qualification &#39;PolishedDecoration::&#39; on member &#39;drawBlend&#39;修改：路径：./root/yizhi/qtopia-free-2.2.0/qtopia/src/plugins/decorations/polished/polished.h（58行）去掉’PolishedDecoration::’ 2.8.12inputmethods.cpp:86: error: extra qualification &#39;IMToolButton::&#39; on member &#39;IMToolButton&#39;修改：路径：./root/yizhi/qtopia-free-2.2.0/qtopia/src/server/inputmethods.cpp（86行）去掉’IMToolButton::’ 2.9类型转换错误2.9.1backend/vobject.cpp:419: error: invalid conversion from &#39;const char*&#39; to &#39;char*&#39;修改：./root/yizhi/qtopia-free-2.2.0/qtopia/src/libraries/qtopia/backend/vobject.cpp（419行）改为：1char *dot = (char *)strrchr(g,'.'); 2.9.2wavplugin.cpp:435: error: invalid conversion from &#39;const char*&#39; to &#39;char*&#39;修改：/root/yizhi/qtopia-free-2.2.0/qtopia/src/plugins/codecs/wavplugin/wavplugin.cpp（435行）改为：1char *ext = (char *)strrchr( path.latin1(), '.' ); 2.10库文件位置/root/yizhi/qtopia-free-2.2.0/qtopia/lib/libqte.so: undefined reference to &#39;ts_read_raw&#39; /root/yizhi/qtopia-free-2.2.0/qtopia/lib/libqte.so: undefined reference to &#39;ts_open&#39; /root/yizhi/qtopia-free-2.2.0/qtopia/lib/libqte.so: undefined reference to &#39;ts_fd&#39; /root/yizhi/qtopia-free-2.2.0/qtopia/lib/libqte.so: undefined reference to &#39;ts_config&#39; /root/yizhi/qtopia-free-2.2.0/qtopia/lib/libqte.so: undefined reference to &#39;ts_close&#39; /root/yizhi/qtopia-free-2.2.0/qtopia/lib/libqte.so: undefined reference to ts_read&#39;修改：把/usr/local/tslib下的相关库libts-0.0.so.*类拷到/usr/local/arm/arm-2009q3/arm-none-linux-gnueabi/libc/lib下面 2.11缺少文件致命错误： linux/videodev.h：没有那个文件或目录12编译中断。make[6]: *** [.obj/release-shared/videocaptureview.o] 错误 1 解决方法修改：/root/yizhi/qtopia-free-2.2.0/qtopia/src/applications/camera/videocaptureview.cpp（54行）改为：1#inlude &lt;libv4l1-videodev.h&gt; 以上是在飞凌嵌入式S5PV210 OK210开发板上的操作。","tags":[{"name":"嵌入式arm","slug":"嵌入式arm","permalink":"https://yaris079.github.io/tags/嵌入式arm/"}]},{"title":"Qt_arm","date":"2017-05-07T13:05:31.000Z","path":"2017/05/07/Qt-arm/","text":"Qt是一个跨平台的C++图形用户界面应用程序框架，它提供给应用程序开发者建立艺术级的图形用户界面所需的所用功能。Qt是完全面向对象的，很容易扩展并且允许真正的组件编程。Qt的嵌入式开发，一般分为PC版，嵌入式x86版和ARM 3个版本，开发人员先在PC环境下完成程序设计，这样比较方便调试和修改。然后用交叉编译器重新编译程序，将可执行程序和Qt的ARM版本库复制到ARM开发板里执行即可。因此，我们要安装两个版本，PC版本和ARM版本。 主机环境Qt构建直接采用apt-get install的方式安装：1apt-get install qt-sdk 系统会自动安装PC版Qt，安装完成后，qtcreator执行文件在/usr/bin中，Qt的内置文件在/usr/share/qt5中。 目标机Qt环境构建嵌入式Qt可以到其官网下载，目前最高版本应该是Qt libraries4.8.5 for embedded Linux。网址是http://qt-project.org/downloads，http://download.qt.io/archive/qt/4.8/4.8.5/下载的文件名为qt-everywhere-opensource-src-4.8.5.tar。 1.Qt的ARM编译首先进入下载目录，将下载的压缩文件解压。命令如下：12cd home/zynq/ #进入你的下载目录tar xvzf qt-everywhere-opensource-src-4.8.5.tar 解压完成后，会创建qt-everywhere-opensource-src-4.8.5文件夹，嵌入式Qt源码就在该文件夹下进行配置。首先要修改配置文件，打开qt-everywhere-opensource-src-4.8.5/mkspecs/qws/linux-arm-gnueabi-g++/qmake.conf文件，将arm-none-linux-gnueabi-全部改为交叉编译器名字arm-xilinx-linux-gnueabi-。为防止出现某些指令找不到的错误，将qt-everywhere-opensource-src-4.8.5/mkspecs/common/g++-unix.conf进行修改，将编译优化置为0。1234将QMAKE_LFLAGS_RELEASE += -W1, -O1这一行修改为QMAKE_LFLAGS_RELEASE += -W1, -O0 配置文件修改完成后就可以进行配置了，命令如下：123456789./configure \\-prefix /usr/local/Trolltech/QtEmbedded-4.6.3-arm \\-opensource \\-confirm-license \\-embedded arm \\-xplatform qws/linux-arm-gnueabi-g++ \\-little-endian -host-little-endian \\-no-pch \\-nomake examples -nomake demos 该代码用于对Qt库的裁剪配置，因为Qt库过大，如果完全编译的话，可能最终arm板负载不了，所以需要裁剪。而裁剪的参数没有规定的，你甚至可以不裁剪，但一般情况会把鼠标库，例子，样例代码等去掉。你可以输入./configure -help来查看各选项的含义，但都是英文的。以上“\\”符号表示该行命令没有结束，接着下一行。如果把上述代码复制到终端命令行没有出错，则会出现一个提示选择信息，那是QT安装的版本选择信息，一般选择“O”，意思是开源(opensource)，然后继续。 本代码第二行-prefix后的地址就是编译安装的地址。 配置完成后就可以对源代码进行编译了，编译时间比较长，大概需要1~2个小时，编译命令如下：1make 成功编译后，执行安装命令，命令如下：1make install 2.配置ARM下的QtCreator打开QtCreator，在菜单栏选择tool→Options命令，打开QtCreator设置选项，单击左侧的Build&amp;Run按钮。首先配置编译工具，使用交叉编译器。右侧选择Compilers(编译器)，可以看到默认的是x86下的GCC，只能编译PC下运行的Qt程序。单击右侧的Add(添加)按钮，选择GCC，增加ARM下的编译器，输入编译器名字和路径，路径为root/CodeSourcery/Sourcery_CodeBench_Lite_for_Xilinx_GNU_Linux/bin/arm-xilinx-linux-gnueabi-g++，单击Apply(应用)按钮。切换到Qt Versions(Qt版本)选项，单击Add按钮，弹出qmake选择窗口，选择路径为/usr/local/Trolltech/QtEmbedded-4.6.3-arm/bin/qmake。切换到Kits(配置套件)选项，单击Add按钮，添加名称为QtEmbedded-4.8.5-arm，设备类型选择Android Device，编译器和Qt Versions均选择我们新添加的。点击OK按钮完成设置。","tags":[{"name":"嵌入式arm","slug":"嵌入式arm","permalink":"https://yaris079.github.io/tags/嵌入式arm/"}]},{"title":"Xilinx_arm交叉编译器安装","date":"2017-05-07T06:18:36.000Z","path":"2017/05/07/Xilinx-arm/","text":"本文所有的操作请在root用户下完成 。如何使用root登录请自行百度，google。 1.下载交叉编译器首先下载官方制作好的交叉编译器http://xilinx.wikidot.com/zynq-tools，下载的文件为xilinx-2011.09-50-arm-xilinx-linux-gnueabi.bin 2.安装32位库64位的系统用户在安装GNU工具包时可能会遇到找不到依赖关系的问题，这是由于Ubuntu64位发行版少一些32位库。可以通过如下命令安装：1apt-get install ia32-libs Ubuntu16.04已经不再支持这个源，可以使用以下操作安装。查看现有架构：1dpkg --print-architecture 你将会看到像下面这样的内容:1amd64 打开多架构支持，下载安装32位库：123dpkg--add-architecturei386apt-get updatesudo apt-get install libc6:i386 3.Xilinux ARM交叉编译器的安装 1） Xilinx提供的直接可用的交叉编译器xilinx-2011.09-50-arm-xilinx-linux-gnueabi.bin。接下来安装交叉编译器，指令如下：123chmod +x xilinx-2011.09-50-arm-xilinx-linux-gnueabi.bin //将其设置成可执行文件sudo dpkg-reconfigure -plow dash //这一步只为了修复/bin/sh指向dash而不是bash或其他支持的shell的错误。执行命令后，在出现的界面中，选择否./xilinx-2011.09-50-arm-xilinx-linux-gnueabi.bin //开始安装 在安装过程中，安装向导会给出选择“Add product to the PATH?”。若选择“Do not modify PATH.”，则需要在安装完成后手动添加环境变量，接下来会讲到。安装路径可以用默认路径，为 /root/CodeSourcery/Sourcery_CodeBench_Lite_for_Xilinx_GNU_Linux 2）安装完后，若需要手动添加环境变量，以后每次编译软件的时候都需要通过export指令将编译环境路径加入到PATH环境变量，在终端中输入命令如下：123export ARCH=armexport CROSS_COMPILE=arm-xilinx-linux-gnueabi-export PATH=/root/CodeSourcery/Sourcery_CodeBench_Lite_for_Xilinx_GNU_Linux/bin/:$PATH 若不想每次都输入，就在通过gedit /etc/bash.bashrc指令打开bash.bashrc文件，在里面加入上述指令，这样开机就会自动执行了。 至此，系统环境已搭成，可以通过如下命令来验证：1arm-xilinx-linux-gnueabi-gcc -v //打印版本命令。如果可以打印出交叉编译器的版本信息，则说明系统环境设置成功。 在最后一行会显示编译器的版本信息。","tags":[{"name":"嵌入式arm","slug":"嵌入式arm","permalink":"https://yaris079.github.io/tags/嵌入式arm/"}]}]
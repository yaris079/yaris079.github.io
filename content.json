[{"title":"ZYNQ之uboot，kernel，设备树，文件系统生成","date":"2018-07-20T07:24:40.000Z","path":"2018/07/20/ZYNQ之uboot，kernel，设备树，文件系统生成/","text":"一、 交叉编译器：使用xilinx提供的编译器arm-xilinx-linux-gnueabi- Version 4.6.1版本。 1. 添加交叉编译器的环境变量：123export ARCH=armexport CROSS_COMPILE=arm-xilinx-linux-gnueabi-export PATH=/root/CodeSourcery/Sourcery_CodeBench_Lite_for_Xilinx_GNU_Linux/bin/:$PATH 2. 检验交叉编译器安装是否成功：在终端输入arm-xilinx-linux-gnueabi-gcc –v 查看版本号； 说明安装成功。 二、u-boot使用从xilinx的github仓库上下载的u-boot-xlnx-xilinx-v2015.4.zip版本。下载dtc编译器。https://git.kernel.org/pub/scm/utils/dtc/dtc.git参考xilinx的wiki http://www.wiki.xilinx.com/Fetch%20Sources 1.u-boot编译过程中需要用到dtc编译器，根据xilinx的wiki指导进行下载。1git clone https://git.kernel.org/pub/scm/utils/dtc/dtc.git 进入dtc目录，执行make命令12cd dtcmake 执行make指令之前请先将xillinx tools 添加至环境变量。xillinx tools在Xilinx SDK中。构建过程完成后，将在当前目录中创建dtc二进制文件。必须使工具可访问dtc二进制文件的路径（例如，U-Boot构建过程）。要在其他步骤中使用dtc，建议将tools目录添加到$PATH变量中。 这里还可以直接使用 apt-get install device-tree-compiler 安装dtc编译器，省去了自己下载源代码编译的麻烦。 2.配置u-boot将u-boot解压，并进入到解压目录下。12unzip u-boot-xlnx-xilinx-v2015.4.zipcd u-boot-xlnx-xilinx-v2015.4 将u-boot配置SDRAM大小为 512M大小，添加QSPI支持。1vim u-boot-xlnx-xilinx-v2015.4/include/configs/zynq_zed.h 添加以下宏，之后保存退出。 3.编译u-boot如果第一步配置好了环境变量，直接执行：123make distcleanmake zynq_zed_configmake 编译完成后，生成ELF格式的u-boot文件，将其重命名为”u-boot.elf”。并注意生成mkconfig可执行文件，制作文件系统时会用到。 编译U-boot时会遇到2个错误。原因很简单，就从一开始的错误提示着手： fatal error: openssl/evp.h: 没有那个文件或目录。当然在网上也可以搜索到相关的解决方法。在此仅作为记录：如果你在编译时遇到这个错误，这可能是下面的原因：你尝试编译的程序使用OpenSSL，但是需要和OpenSSL链接的文件（库和头文件）在你Linux平台上缺少,所以要自己安装相关的文件。 要在Ubuntu上安装OpenSSL：1$ sudo apt-get install libssl-dev 4.使用xilinx SDK 制作boot.bin在xilinx SDK中新建一个工程，使用 Zynq FSBL 模板，直接编译生成FSBL.elf。在SDK界面选择Xilinx Tools-&gt;Create Zynq Boot Image弹出上面对话框来生成boot文件。依次按顺序添加FSBL.elf、system.bit和u-boot.elf文件。System.bit是使用Vivado生成的比特流文件， u-boot.elf就是我们刚生成的文件。最后制定输出目录生成BOOT.BIN文件。 三、内核kernel编译Linux内核首先我们也要先下载源码并解压，设置交叉编译环境，导入内核配置，然后编译。内核文件linux-xlnx-xilinx-v2015.4.zip 也可以在xilinx的github仓库找到。编译后生成的文件为zImage，位于arch/arm/boot/目录下，这里我们需要制作未经压缩过的内核镜像uImage。编译uImage过程中需要用到mkimage，可以在uboot文件夹的tools目录下找到。1234unzip linux-xlnx-xilinx-v2015.4.zipmake xilinx_zynq_defconfigmakemake UIMAGE_LOADADDR=0x8000 uImage -j8 编译完成后，在 arch/arm/boot 下生成未经压缩过的内核镜像uImage,在arch/arm/boot/dts 目录下生成zynq-zed.dts设备树文件。 四、设备树文件使用编译kernel时候生成的zynq_zed.dts进行编译设备树文件 zynq_zed.dtb。 1. 配置dtc的环境变量在kernel/scripts/dtc/下有dtc命令文件，使用这个命令可以生成.dtb文件。打开~/.bashrc文件，在最后添加：（按实际情况添加具体路径）export PATH=$PATH:~/xillinx/linux-xlnx-xilinx-v2014.4/scripts/dtc 2. 按需要改写.dts文件devicetree的生成依赖于FPGA工程中ZYNQ的配置，方法请参考：http://blog.chinaaet.com/cuter521/p/5100001052 3. 生成.dtb文件在arch/arm/boot/dts目录下使用如下命令生成devicetree.dtb文件。1dtc -I dts -O dtb -o devicetree.dtb zynq-zed.dts 五、根文件系统1.解压压缩包。12gunzip arm_ramdisk.image.gzchmod u+rwx arm_ramdisk.image 2.创建目录并挂载ramdisk：12mkdir file_systemmount arm_ramdisk.image file_system 3.修改file_system内容，由于我们未使用到sd卡，因此将/etc/fstab中的最后两行删除掉。完成修改后卸载。1umount file_system 4.压缩文件系统。1gzip arm_ramdisk.image 5.生成uramdisk.image.gz文件。1mkimage -A arm -T ramdisk -C gzip -d arm_ramdisk.image.gz uramdisk.image.gz 六、 按照zynq_zed.dts中的分区，烧写BOOT.bin、devicrtree.dtb、uImage、ramdisk：1.首先使用SD卡启动，进入u-boot命令行； 2.开启TFTP服务器，使用tftp将BOOT.bin通过网络烧写道qspi的0x0地址：1234tftp 0x800000 BOOT.bin //加载到内存sf probe 0 0 0sf erase 0x0 0x100000 //擦除1M空间sf write 0x800000 0x0 0x100000 //写入qspi 3.烧写 uImage123tftp 0x800000 uImage sf erase 0x100000 0x600000sf write 0x800000 0x100000 0x600000 4.烧写 devicetree.dtb123tftp 0x800000sf erase 0x700000 0x100000sf write 0x800000 0x700000 0x100000 5.烧写 ramdisk123tftp 0x4000000 ramdisksf erase 800000 1200000sf write 0x4000000 800000 1200000 6.烧写 fpga生成的 xx.bit程序123tftp 0x4000000 xx.bitsf erase 1A00000 500000sf write 0x8000000 1A00000 500000 七、 设置u-boot参数及启动方式：将板卡启动方式改为qspi启动.进入u-boot命令行,输入命令：123setenv bootcmd 'sf probe 0 0 0 &amp;&amp; echo qspi-bitstream is loading ... ... &amp;&amp; sf read 0x800000 0x1A00000 0x500000 &amp;&amp; fpga loadb 0 0x800000 0x400000 &amp;&amp; echo uIamge is loading ... ... &amp;&amp; sf read 0x2080000 0x100000 0x600000 &amp;&amp;echo deviceTree is loading ... ... &amp;&amp; sf read 0x2000000 0x700000 0x100000 &amp;&amp; echo ramdisk.image is loading ... ... &amp;&amp; sf read 0x4000000 0x800000 0x1200000 &amp;&amp; bootm 0x2080000 0x4000000 0x2000000'saveenv 八、 重启板卡，顺利从qspi启动:","tags":[]},{"title":"qtopia的使用","date":"2018-05-25T21:42:39.000Z","path":"2018/05/26/qtopia的使用/","text":"一、qtopia的安装：前面我们已经编译好了arm版和PC版的qtopia2.2.0。进入qtopia-free-2.2.0，我们可以看到4个文件用于设置环境变量： setQpeEnv：QTOPIA用的！ setQteEnv：嵌入式开发用的声明文件； setDqtEnv setQt2Env 依次运行：1、虚拟窗口运行：$cd qtopia/bin$qvfb -width 640 -height 480&amp;$./qpe -qws 二、添加自己的程序到Qtopia:1、复制一个实例程序$cd somewhere$cp -r $QPEDIR/examples/application .$chmod +w application/*$cd application 2、生成 Makefile文件:$qmake -spec $QPEDIR/mkspecs/qws/linux-generic-g++ application.pro 3、 编译:$make 4、安装程序到qtopia：$make install INSTALL_ROOT=$QPEDIR 删除程序一定要在这个目录下$make uninstall INSTALL_ROOT=$QPEDIR 5.测试：$cd $QPEDIR/bin$qvfb &amp;$./example -qws我们会看到在Applications栏里出现了example，打开可以运行！ 注意：不过此时我们可以看到应用程序没有图标，我们可以将图标文件复制到$QPEDIR/image/opt/Qtopia/pic目录下，我们还可以自己再建个文件夹例如example把图标放在此目录下，系统会自动搜索的！ 三、编写自己的hello world!1、编译：进入qt2/tutorial（这是自带的一些教程源码）我们来个最简单的，复制t1文件夹，只留下main.cpp 就可以了，$qmake -project CONFIG+=qtopia TARGET=hello这样就生成了t1.pro工程文件，因为默认是没有config 和target 的，我们自己添上；哈哈$qmake -spec $QPEDIR/mkspecs/qws/linux-generic-g++ t1.pro这样就生成了Makefile文件；$make就生成了hello 2、测试：$qvfb &amp;$./hello -qws可以看到我们的hello world! 了。 四、自己使用designer来设计hello world！1、designer//启动qtopia自带的designer！设计界面，hello world!其中：窗体名为: Form1;保存文件，test/form.ui 打开designer后如果发现窗口都是透明的看不清楚内容，这是ubuntu开启了透明效果，可以# XLIB_SKIP_ARGB_VISUALS=1 designer,但关闭shell后重新打开又会这样。也可以在登陆时选择ubuntu 2D，或者编辑/etc/profie,加入export XLIB_SKIP_ARGB_VISUALS=1注销后重新登陆，这时ubuntu也关闭了透明效果。打开designer后选择file–&gt;new–&gt;widget新建一个窗体 2、编写main.cpp文件：123456789include include \"form.h\"int main(int argc, char *argv[])&#123;QApplication app(argc, argv);Form1 w;w.show();return app.exec();&#125; 3、生成工程文件：$qmake -project CONFIG+=qtopia TARGET=test 4、生成Makefile文件：$qmake -spec $QPEDIR/mkspecs/qws/linux-generic-g++ test.pro$make 5.测试：$qvfb &amp;$./test -qws 五、将自己写的hello world 放到qtopia系统下运行：1、编写test.desktop123456789[Translation]File=example-nctContext=test[Desktop Entry]Comment[]=An Example ProgramExec=testIcon=testType=ApplicationName[]=test 把test.desktop放在$QPEDIR/apps/Applications目录下 2、编辑图标文件，test.png把test.png放在$QPEDIR/pics目录下，也可以在此目录下建自己的目录。 3、测试：$cd $QPEDIR/bin$./test -qws可以看到我们的test程序","tags":[{"name":"arm嵌入式","slug":"arm嵌入式","permalink":"https://yaris079.github.io/tags/arm嵌入式/"}]},{"title":"qtopia2-2-0-pc在Ubuntu下的编译","date":"2018-05-25T12:43:21.000Z","path":"2018/05/25/qtopia2-2-0-pc在Ubuntu下的编译/","text":"下载所需的库文件apt-get install libx11-dev libxext-dev libxtst-devapt-get install uuid-devapt-get install libxmu-dev libxmu6apt-get install libwxgtk2.8-0 libwxgtk2.8-dev wx2.8-headers wx-commonapt-get install libsmbclient-devapt-get install libcupsys2-devapt-get install libopensc2-devapt-get install build-essentialapt-get install libx11-devapt-get install libxmu-devapt-get install libjpeg-devapt-get install libpng-devapt-get install zlib1g-devapt-get install lib32z1-devapt-get install bisonapt-get install flexapt-get install lib32ncurses5-devapt-get install libx11-devapt-get install gperf 注意！ 使用gcc编译qtopia2.2.0需要使用gcc4.4及以下版本gcc，g++改为高版本的随时用update-alternatives –config 命令切换！","tags":[{"name":"嵌入式arm","slug":"嵌入式arm","permalink":"https://yaris079.github.io/tags/嵌入式arm/"}]},{"title":"qtopia2.2.0-arm在Ubuntu下的编译","date":"2018-05-25T05:42:18.000Z","path":"2018/05/25/qtopia2-2-0-arm在Ubuntu下的编译/","text":"1.编译第三方库编译qtopia-free-forlinx-2.2.0 前确认已经把您刚 才制作的/root/yizhi/arminclude 下的文件放到交叉编译器目录 “arm-none-linux-gnueabi\\libc\\usr\\include” 里面，所有的库文件放到交叉编译器安装目录的“arm-none-linux-gnueabi\\libc\\usr\\lib” 文件夹下面 另外需要注意的是用官方提供的 Qtopia2.2.0 源代码编译出来的版本，主界面的图标下会出现一条虚线，影响美观，将ARM-qtopia-free-src-2.2.0.tar.gz解压到 /root/yizhi 文 件 夹 后（yizhi 是自己建立的文件夹），打开qtopia-free-2.2.0/qtopia/src/qt/qconfig-qpe.h 文件，在里面增加以下内容即可解决虚线的问题：1#define QT_NO_QWS_GFX_SPEED 修改脚本脚本里面有编译时需要的环境变量：gedit build 注意：编译过程中产生的状态信息将记录到当前目录下的 qtopia2.2.0Makelog 文件里面，如果编译过程中产生了大量的错误信息，打开该文件，查找 error 关键字进行问题的定位，里面记录的信息对您很有帮助，有时焦点不会停留在出现错误的位置，这时查看日志文件就很重要了。 2 常见bug2.1 open函数缺少必要的参数 错误信息：In function ‘int open(const char*, int, ...)’, inlined from ‘QMemoryFileData* QMemoryFile::openData(const QString&amp;, int, uint)’ at tools/qmemoryfile_unix.cpp:143:54: /usr/include/i386-linux-gnu/bits/fcntl2.h:51:26: error: call to ‘__open_missing_mode’ declared with attribute error: open with O_CREAT in second argument needs 3 arguments 修改： 文件路径：（此错误有两处） /root/yizhi/qtopia-free-2.2.0/qt2/src/tools/qmemoryfile_unix.cpp 找到：（143行） /root/yizhi/qtopia-free-2.2.0/qtopia/src/libraries/qtopia/qmemoryfile_unix.cpp 找到：（141行） 1f = ::open(tmpFile.latin1(), O_CREAT | O_WRONLY); 修改为：1f = ::open(tmpFile.latin1(), O_CREAT | O_WRONLY, 0666); 2.2缺少头文件错误错误信息：../include/qmap.h:107:13: error: ‘ptrdiff_t’ does not name a type ../include/qmap.h:223:13: error: ‘ptrdiff_t’ does not name a type ../include/qvaluelist.h:88:13: error: ‘ptrdiff_t’ does not name a type ../include/qvaluelist.h:164:13: error: ‘ptrdiff_t’ does not name a type make[2]: *** [.obj/release-shared-mt/qapplication_x11.o] Error 1修改方法： 在qtopia-free-2.2.0/dqt/include的qvaluelist.h和qmap.h文件下增加两个头文件：12#include \"stddef.h\"#include &lt;cstddef&gt; 搜索文件命令: find –name “qmap.h” 2.3 使用未定义的类错误信息：/root/yizhi/qtopia-free-2.2.0/qt2/include/qwindowsystem_qws.h:230: error: &#39;QWSInputMethod&#39; has not been declared /root/yizhi/qtopia-free-2.2.0/qt2/include/qwindowsystem_qws.h:237: error: &#39;QWSGestureMethod&#39; has not been declared make[1]: *** [allmoc.o] Error 1修改：cd /root/yizhi/qtopia-free-2.2.0/qt2/src/kernelgedit qwindowsystem_qws.h在前面增加以下两行12class QWSInputMethod; class QWSGestureMethod; 保存退出，继续编译 2.4缺少uuid库Creating pngscale...make[1]: Entering directory /root/yizhi/qtopia-free-2.2.0/qtopia/util/pngscal .................................................................make[1]: *** [../../bin/pngscale] Error 1 make[1]: Leaving directory /root/yizhi/qtopia-free-2.2.0/qtopia/util/pngscal Failed to make pngscale修改方法：apt-get install uuid-dev 2.5缺少系统头文件错误信息：kernel/qpixmapcache.cpp:125: fatal error: asm/page.h: No such file or directory compilation terminated. make[1]: *** [tmp/release-shared-linux-arm-g++-no-keypad/kernel/qpixmapcache.o] Error 1 make[1]: Leaving directory /root/yizhi/qtopia-free-2.2.0/qt2/src&#39;修改：路径(两个地方)：/root/yizhi/qtopia-free-2.2.0/qt2/src/kernel/qpixmapcache.cpp 第125行./root/yizhi/qtopia-free-2.2.0/qt2/tools/qvfb/qvfbview.cpp 第39行修改为：1234#define PAGE_SHIFT 12#define PAGE_SIZE(1UL &lt;&lt; PAGE_SHIFT)#define PAGE_MASK(~(PAGE_SIZE-1))//#include//PAGE_SIZE,PAGE_MASK,PAGE_ALIGN 这样修改是因为新的 Linux 内核源代码中已经不包含该头文件了。 2.6 this指针错误信息：root/yizhi/qtopia-free-2.2.0/qt2/include/qvaluestack.h:57:6: error: cannot convert ‘QValueList&lt;qmap &gt;::Iterator {aka QValueListIterator&lt;qmap &gt;}&lt;/qmap&lt;/qmap’ to ‘const char*’ for argument ‘1’ to ‘int remove(const char*)’ /root/yizhi/qtopia-free-2.2.0/qt2/include/qvaluestack.h: In member function ‘T QValueStack::pop() [with T = QString]’: xml/qxml.cpp:2532:57: instantiated from here /root/yizhi/qtopia-free-2.2.0/qt2/include/qvaluestack.h:57:6: error: cannot convert ‘QValueList::Iterator {aka QValueListIterator}’ to ‘const char*’ for argument ‘1’ to ‘int remove(const char*)’ make[1]: *** [tmp/release-shared-linux-g++/xml/qxml.o] Error 1修改：路径:./root/yizhi/qtopia-free-2.2.0/qt2/src/include/qvaluestack.h(57行)将 remove( this-&gt;fromLast() );改为 this-&gt;remove( this-&gt;fromLast() );保存退出 2.7 缺少文件错误信息：../../../include/qtopia/custom-qtopia.h:1: fatal error: ../../src/libraries/qtopia/custom-linux-arm-g++.h: No such file or directory compilation terminated. make[5]: *** [.obj/release-shared/qpeapplication.o] Error 1修改：路径：/yizhi/qtopia-free-2.2.0/qtopia/src/libraries/qtopia进入该路径后执行以下命令：cp custom-linux-ipaq-g++.cpp custom-linux-arm-g++.cppcp custom-linux-ipaq-g++.h custom-linux-arm-g++.h 2.8一类出现较多的错误2.8.1错误信息： qdawg.cpp:294: error: extra qualification &#39;QDawgPrivate::&#39; on member &#39;QDawgPrivate&#39;修改：路径：./root/yizhi/qtopia-free-2.2.0/qtopia/src/libraries/qtopia/qdawg.cpp（294行）去掉’QDawgPrivate::’ 2.8.2错误信息：thumbnailview_p.h:81: error: extra qualification &#39;ThumbnailItem::&#39; on member &#39;paintItem&#39;修改：路径：/root/yizhi/qtopia-free-2.2.0/qtopia/src/libraries/qtopia2/thumbnailview_p.h（81行）去掉’ThumbnailItem::’ 2.8.3错误信息：abtable_p.h:276: error: extra qualification &#39;PhoneTypeSelector::&#39; on member &#39;addType&#39;修改：路径：/root/yizhi/qtopia-free-2.2.0/qtopia/src/libraries/qtopiapim/abtable_p.h（276行）去掉’PhoneTypeSelector::’ 2.8.4错误信息：numberentry_p.h:106: error: extra qualification &#39;NumberEntryDialog::&#39; on member &#39;eventFilter&#39;修改：路径/root/yizhi/qtopia-free-2.2.0/qtopia/src/libraries/qtopiapim/numberentry_p.h（106行）去掉’NumberEntryDialog::’ 2.8.5错误信息：videoviewer.cpp:52: error: extra qualification &#39;SimpleVideoWidget::&#39; on member &#39;SimpleVideoWidget&#39;修改：./root/yizhi/qtopia-free-2.2.0/qtopia/src/libraries/mediaplayer/videoviewer.cpp （52行）去掉’SimpleVideoWidget::’ 2.8.6错误信息：ablabel.h:78: error: extra qualification &#39;AbLabel::&#39; on member &#39;decodeHref&#39;修改：路径：/root/yizhi/qtopia-free-2.2.0/qtopia/src/applications/addressbook/ablabel.h（78行）去掉’AbLabel::’ 2.8.7错误信息：minefield.h:105: error: extra qualification &#39;MineField::&#39; on member &#39;setState&#39; minefield.h:106: error: extra qualification &#39;MineField::&#39; on member &#39;placeMines修改：路径：./root/yizhi/qtopia-free-2.2.0/qtopia/src/games/minesweep/minefield.h（105 106行）去掉’MineField::’ 2.8.8buttoneditordialog.h:56: error: extra qualification &#39;ButtonEditorDialog::&#39; on member &#39;actionFor&#39;修改：路径：./root/yizhi/qtopia-free-2.2.0/qtopia/src/settings/buttoneditor/buttoneditordialog.h（56行）去掉’ButtonEditorDialog::’ 2.8.9packagewizard.h:106: error: extra qualification &#39;PackageWizard::&#39; on member &#39;current&#39;修改：./root/yizhi/qtopia-free-2.2.0/qtopia/src/settings/qipkg/packagewizard.h（106行）去掉’PackageWizard::’ 2.8.10keyboard.h:60: error: extra qualification &#39;KeyboardPicks::&#39; on member &#39;KeyboardPicks&#39;修改：路径：./root/yizhi/qtopia-free-2.2.0/qtopia/src/plugins/inputmethods/keyboard/keyboard.h（60行）去掉~ KeyboardPicks前面的’KeyboardPicks::’ 2.8.11polished.h:58: error: extra qualification &#39;PolishedDecoration::&#39; on member &#39;drawBlend&#39;修改：路径：./root/yizhi/qtopia-free-2.2.0/qtopia/src/plugins/decorations/polished/polished.h（58行）去掉’PolishedDecoration::’ 2.8.12inputmethods.cpp:86: error: extra qualification &#39;IMToolButton::&#39; on member &#39;IMToolButton&#39;修改：路径：./root/yizhi/qtopia-free-2.2.0/qtopia/src/server/inputmethods.cpp（86行）去掉’IMToolButton::’ 2.9类型转换错误2.9.1backend/vobject.cpp:419: error: invalid conversion from &#39;const char*&#39; to &#39;char*&#39;修改：./root/yizhi/qtopia-free-2.2.0/qtopia/src/libraries/qtopia/backend/vobject.cpp（419行）改为：1char *dot = (char *)strrchr(g,'.'); 2.9.2wavplugin.cpp:435: error: invalid conversion from &#39;const char*&#39; to &#39;char*&#39;修改：/root/yizhi/qtopia-free-2.2.0/qtopia/src/plugins/codecs/wavplugin/wavplugin.cpp（435行）改为：1char *ext = (char *)strrchr( path.latin1(), '.' ); 2.10库文件位置/root/yizhi/qtopia-free-2.2.0/qtopia/lib/libqte.so: undefined reference to &#39;ts_read_raw&#39; /root/yizhi/qtopia-free-2.2.0/qtopia/lib/libqte.so: undefined reference to &#39;ts_open&#39; /root/yizhi/qtopia-free-2.2.0/qtopia/lib/libqte.so: undefined reference to &#39;ts_fd&#39; /root/yizhi/qtopia-free-2.2.0/qtopia/lib/libqte.so: undefined reference to &#39;ts_config&#39; /root/yizhi/qtopia-free-2.2.0/qtopia/lib/libqte.so: undefined reference to &#39;ts_close&#39; /root/yizhi/qtopia-free-2.2.0/qtopia/lib/libqte.so: undefined reference to ts_read&#39;修改：把/usr/local/tslib下的相关库libts-0.0.so.*类拷到/usr/local/arm/arm-2009q3/arm-none-linux-gnueabi/libc/lib下面 2.11缺少文件致命错误： linux/videodev.h：没有那个文件或目录12编译中断。make[6]: *** [.obj/release-shared/videocaptureview.o] 错误 1 解决方法修改：/root/yizhi/qtopia-free-2.2.0/qtopia/src/applications/camera/videocaptureview.cpp（54行）改为：1#inlude &lt;libv4l1-videodev.h&gt; 以上是在飞凌嵌入式S5PV210 OK210开发板上的操作。","tags":[{"name":"嵌入式arm","slug":"嵌入式arm","permalink":"https://yaris079.github.io/tags/嵌入式arm/"}]},{"title":"Qt_arm","date":"2017-05-07T13:05:31.000Z","path":"2017/05/07/Qt-arm/","text":"Qt是一个跨平台的C++图形用户界面应用程序框架，它提供给应用程序开发者建立艺术级的图形用户界面所需的所用功能。Qt是完全面向对象的，很容易扩展并且允许真正的组件编程。Qt的嵌入式开发，一般分为PC版，嵌入式x86版和ARM 3个版本，开发人员先在PC环境下完成程序设计，这样比较方便调试和修改。然后用交叉编译器重新编译程序，将可执行程序和Qt的ARM版本库复制到ARM开发板里执行即可。因此，我们要安装两个版本，PC版本和ARM版本。 主机环境Qt构建直接采用apt-get install的方式安装：1apt-get install qt-sdk 系统会自动安装PC版Qt，安装完成后，qtcreator执行文件在/usr/bin中，Qt的内置文件在/usr/share/qt5中。 目标机Qt环境构建嵌入式Qt可以到其官网下载，目前最高版本应该是Qt libraries4.8.5 for embedded Linux。网址是http://qt-project.org/downloads，http://download.qt.io/archive/qt/4.8/4.8.5/下载的文件名为qt-everywhere-opensource-src-4.8.5.tar。 1.Qt的ARM编译首先进入下载目录，将下载的压缩文件解压。命令如下：12cd home/zynq/ #进入你的下载目录tar xvzf qt-everywhere-opensource-src-4.8.5.tar 解压完成后，会创建qt-everywhere-opensource-src-4.8.5文件夹，嵌入式Qt源码就在该文件夹下进行配置。首先要修改配置文件，打开qt-everywhere-opensource-src-4.8.5/mkspecs/qws/linux-arm-gnueabi-g++/qmake.conf文件，将arm-none-linux-gnueabi-全部改为交叉编译器名字arm-xilinx-linux-gnueabi-。为防止出现某些指令找不到的错误，将qt-everywhere-opensource-src-4.8.5/mkspecs/common/g++-unix.conf进行修改，将编译优化置为0。1234将QMAKE_LFLAGS_RELEASE += -W1, -O1这一行修改为QMAKE_LFLAGS_RELEASE += -W1, -O0 配置文件修改完成后就可以进行配置了，命令如下：123456789./configure \\-prefix /usr/local/Trolltech/QtEmbedded-4.6.3-arm \\-opensource \\-confirm-license \\-embedded arm \\-xplatform qws/linux-arm-gnueabi-g++ \\-little-endian -host-little-endian \\-no-pch \\-nomake examples -nomake demos 该代码用于对Qt库的裁剪配置，因为Qt库过大，如果完全编译的话，可能最终arm板负载不了，所以需要裁剪。而裁剪的参数没有规定的，你甚至可以不裁剪，但一般情况会把鼠标库，例子，样例代码等去掉。你可以输入./configure -help来查看各选项的含义，但都是英文的。以上“\\”符号表示该行命令没有结束，接着下一行。如果把上述代码复制到终端命令行没有出错，则会出现一个提示选择信息，那是QT安装的版本选择信息，一般选择“O”，意思是开源(opensource)，然后继续。 本代码第二行-prefix后的地址就是编译安装的地址。 配置完成后就可以对源代码进行编译了，编译时间比较长，大概需要1~2个小时，编译命令如下：1make 成功编译后，执行安装命令，命令如下：1make install 2.配置ARM下的QtCreator打开QtCreator，在菜单栏选择tool→Options命令，打开QtCreator设置选项，单击左侧的Build&amp;Run按钮。首先配置编译工具，使用交叉编译器。右侧选择Compilers(编译器)，可以看到默认的是x86下的GCC，只能编译PC下运行的Qt程序。单击右侧的Add(添加)按钮，选择GCC，增加ARM下的编译器，输入编译器名字和路径，路径为root/CodeSourcery/Sourcery_CodeBench_Lite_for_Xilinx_GNU_Linux/bin/arm-xilinx-linux-gnueabi-g++，单击Apply(应用)按钮。切换到Qt Versions(Qt版本)选项，单击Add按钮，弹出qmake选择窗口，选择路径为/usr/local/Trolltech/QtEmbedded-4.6.3-arm/bin/qmake。切换到Kits(配置套件)选项，单击Add按钮，添加名称为QtEmbedded-4.8.5-arm，设备类型选择Android Device，编译器和Qt Versions均选择我们新添加的。点击OK按钮完成设置。","tags":[{"name":"嵌入式arm","slug":"嵌入式arm","permalink":"https://yaris079.github.io/tags/嵌入式arm/"}]},{"title":"Xilinx_arm交叉编译器安装","date":"2017-05-07T06:18:36.000Z","path":"2017/05/07/Xilinx-arm/","text":"本文所有的操作请在root用户下完成 。如何使用root登录请自行百度，google。 1.下载交叉编译器首先下载官方制作好的交叉编译器http://xilinx.wikidot.com/zynq-tools，下载的文件为xilinx-2011.09-50-arm-xilinx-linux-gnueabi.bin 2.安装32位库64位的系统用户在安装GNU工具包时可能会遇到找不到依赖关系的问题，这是由于Ubuntu64位发行版少一些32位库。可以通过如下命令安装：1apt-get install ia32-libs Ubuntu16.04已经不再支持这个源，可以使用以下操作安装。查看现有架构：1dpkg --print-architecture 你将会看到像下面这样的内容:1amd64 打开多架构支持，下载安装32位库：123dpkg--add-architecturei386apt-get updatesudo apt-get install libc6:i386 3.Xilinux ARM交叉编译器的安装 1） Xilinx提供的直接可用的交叉编译器xilinx-2011.09-50-arm-xilinx-linux-gnueabi.bin。接下来安装交叉编译器，指令如下：123chmod +x xilinx-2011.09-50-arm-xilinx-linux-gnueabi.bin //将其设置成可执行文件sudo dpkg-reconfigure -plow dash //这一步只为了修复/bin/sh指向dash而不是bash或其他支持的shell的错误。执行命令后，在出现的界面中，选择否./xilinx-2011.09-50-arm-xilinx-linux-gnueabi.bin //开始安装 在安装过程中，安装向导会给出选择“Add product to the PATH?”。若选择“Do not modify PATH.”，则需要在安装完成后手动添加环境变量，接下来会讲到。安装路径可以用默认路径，为 /root/CodeSourcery/Sourcery_CodeBench_Lite_for_Xilinx_GNU_Linux 2）安装完后，若需要手动添加环境变量，以后每次编译软件的时候都需要通过export指令将编译环境路径加入到PATH环境变量，在终端中输入命令如下：123export ARCH=armexport CROSS_COMPILE=arm-xilinx-linux-gnueabi-export PATH=/root/CodeSourcery/Sourcery_CodeBench_Lite_for_Xilinx_GNU_Linux/bin/:$PATH 若不想每次都输入，就在通过gedit /etc/bash.bashrc指令打开bash.bashrc文件，在里面加入上述指令，这样开机就会自动执行了。 至此，系统环境已搭成，可以通过如下命令来验证：1arm-xilinx-linux-gnueabi-gcc -v //打印版本命令。如果可以打印出交叉编译器的版本信息，则说明系统环境设置成功。 在最后一行会显示编译器的版本信息。","tags":[{"name":"嵌入式arm","slug":"嵌入式arm","permalink":"https://yaris079.github.io/tags/嵌入式arm/"}]},{"title":"hanoi","date":"2017-04-13T01:58:29.000Z","path":"2017/04/13/hanoi/","text":"汉诺塔问题问题说明汉诺塔问题，就是把A柱子上面从大到小依次叠放的盘子借助B柱移到C柱上去，规则是一次只能移动一个盘子，大盘子不能放到小盘子之上。设有三个塔座A、B、C，n个圆盘。这些圆盘互不相同，初始时，这些编号为1,2，…，n的圆盘从大到小依次放在塔座A上。最底下为最大圆盘。要求将该塔座上的所有圆盘移到另一个塔座C上，并按照同样顺序放置。圆盘移动时，满足以下规则：①一次只能移动一个圆盘；②任何时刻不允许将大的圆盘放在小的圆盘之上；③圆盘可以放在A、B和C的任一塔座上。 思想：我们可以先通过塔座C将n-1个盘子移动到塔座B上，再将第n个盘子从塔座A移动到塔座C上，最后通过塔座A将n-1个盘子从塔座B移动到塔座C上。其中将n-1个盘子从塔座A移动到塔座B上可以视为将n个盘子从塔座A移动到塔座C上的一个子问题。采用递归的方法来解 1.先将塔座A上面的n-1个盘子，移动到塔座B上。 2.然后把塔座A上最大的一个盘子放到塔座C上去。 3.然后把塔座B上面的n-1个盘子移到塔座C上。 步骤：汉诺塔采用递归思想，首先考虑一种临界状态,把n-1个上面的盘从A–&gt;B, 就是把n从A移动到C,最后把n-1个盘从B–&gt;C（注意在考虑把n-1个盘从B—C的时候就出现递归调用，如果把A，B盘交换就又重复上面的流程了，最后到n = 1的时候就返回）。 伪代码： 123456HANOI(n, A, B, C) if n=1 then MOVE(A, 1, C) else HANOI(n-1, A, C, B) MOVE(A, n, C) HANOI(n-1, B, A, C) 界面 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549package hanoi;import java.awt.*;import javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;class Pillar extends JPanel&#123; Label pillar; Pillar() &#123; pillar = new Label(); pillar.setBackground(Color.black); pillar.setBounds(0, 0,4, 180); this.add(pillar); this.setSize(4, 180); //桌子面板大小 this.setLayout(null); &#125;&#125;class Desk extends JPanel //盘子&#123; Label topPanel,leftLeg,rightLeg,name; int num; // 桌子上现有盘子的数量 public int topy=340,topx=80; //第一个个盘子在哪里放下 int maxsize=16; //设置最大盘子数目 int initialx=0,initialy=340; int record[]=new int[16]; Desk(String s) //构造函数 &#123; name=new Label(); name.setText(s); //桌子名称 name.setBounds(70, 20,60, 30); topPanel=new Label(); //桌面 topPanel.setBackground(Color.red); topPanel.setBounds(0, 0,220, 10); this.setSize(220, 50); //桌子面板大小 this.setLayout(null); this.add(topPanel); this.add(name); this.setFont(new Font(\"宋体\",Font.CENTER_BASELINE, 16)); this.setForeground(Color.blue); this.setBackground(Color.WHITE); for (int i=0;i&lt;maxsize;i++) //记录型数组，记录该桌子上放的是哪些盘子，数组元素值为盘子下标。 &#123; record[i]=-1; &#125; &#125; public void Setrecord(int y) //修改记录数组 &#123; record[num-1]=y; //记录最上面的盘子的序号 &#125; public void DeleoneRecord() //当移走某个盘子时，置相应的数组值为-1 &#123; record[num-1]=-1; &#125; public void Setinitialxy(int x ) //修改下一个盘子的盘放位置 &#123; initialx=x; &#125; public void Settopxy() &#123; topx=initialx+num*5; topy=initialy-num*10; &#125; public void Settopx(int x) &#123; topx=initialx+x*5; &#125; public void clear() &#123; num=0; &#125; public void addone() &#123; this.num++; &#125; public void subone() &#123; this.num--; &#125;&#125;class MainPanel extends JPanel&#123; // Pillar pa,pb,pc; Desk a,b,c; int speed; //移动速度 int defaultnum=3; // 初始盘子数 boolean changnum; int maxsize=16; Label plate[]=new Label[maxsize]; int bigestsize=180; //最大盘子的尺寸 int plateHeight=10; int initialx=80; //a座 int initialy=340; int finallyx=680; //c座 int finallyy=340; int moveSpeed=0; //默认为快速完成 int steps=0; //完成步数 public TextField showSpeed=new TextField(\"速度显示区\"); public TextField showAnswer=new TextField(\"动作显示区\"); public TextField showStep=new TextField(\"步数显示区\"); MainPanel() &#123; for(int k=0;k&lt;maxsize;k++) &#123; plate[k]=new Label(); &#125; a=new Desk(\"A 座\"); b=new Desk(\"B 座\"); c=new Desk(\"C 座\"); this.add(a); this.add(b); this.add(c); a.setLocation(60, 350); b.setLocation(360,350); c.setLocation(660,350); pa=new Pillar(); pb=new Pillar(); pc=new Pillar(); this.add(pa); this.add(pb); this.add(pc); pa.setLocation(168, 170); pb.setLocation(468,170); pc.setLocation(768,170); this.add(showSpeed); this.add(showAnswer); this.add(showStep); showSpeed.setBounds(50, 50, 200, 25); showSpeed.setEditable(false); showSpeeds(); showAnswer.setBounds(300, 50, 200, 25); showAnswer.setEditable(false); showStep.setBounds(550, 50, 200, 25); showStep.setEditable(false); this.setBackground(Color.white); this.proplate(defaultnum); //初始化时产生的默认数量的盘子 this.setSize(950,550); this.setLayout(null); a.Setinitialxy(80); b.Setinitialxy(380); c.Setinitialxy(680); a.Settopxy(); b.Settopxy(); c.Settopxy(); changnum=false; validate(); &#125; public void ChangeDefault(int x) &#123; this.defaultnum=x; changnum=true; &#125; public void RemoveAllPlate() &#123; for(int i=0;i&lt;maxsize;i++) &#123; this.remove(plate[i]); &#125; &#125; public void showSpeeds() &#123; String sp; if (this.moveSpeed == -1) sp=\"当前速度为：立即结束\"; else if (this.moveSpeed == 0) sp=\"当前速度为：快速完成\"; else if (this.moveSpeed == 2) sp=\"当前速度为：适中速度\"; else sp=\"当前速度为：较慢实现\"; showSpeed.setText(sp); &#125; public void proplate(int sum) &#123; showAnswer.setText(\"动作显示区\"); showStep.setText(\"步数显示区\"); steps=0; if(changnum==true) &#123; this.RemoveAllPlate(); a.clear(); b.clear(); c.clear(); a.Settopxy(); b.Settopxy(); c.Settopxy(); &#125; for(int su=0;su&lt;sum;su++) //初始化A座 &#123; plate[su].setText(\" \"+su); plate[su].setBackground(Color.black); plate[su].setForeground(Color.red); plate[su].setVisible(true); this.add(plate[su]); a.addone(); //A盘子数加1 a.Setrecord(su); //修改桌子A的记录数组 plate[su].setBounds(initialx+su*5,initialy-su*plateHeight, bigestsize-10*su,plateHeight); &#125; &#125; public void hanoisoon(int n) //立即结束 &#123; /* if (n == 1) &#123; steps++; &#125; else &#123; hanoisoon(n - 1, one, three, two); steps++; hanoisoon(n - 1, two, one, three); &#125;*/ steps=(int)Math.pow(2, n)-1; c.num=n; &#125; public void soonimg(int n) &#123; //初始化三个塔座信息，在C座上画盘子 a.clear(); b.clear(); c.clear(); this.a.Settopxy(); this.b.Settopxy(); this.c.Settopxy(); for(int su=0;su&lt;n;su++) &#123; plate[su].setText(\" \"+su); plate[su].setBackground(Color.black); plate[su].setForeground(Color.red); plate[su].setVisible(true); this.add(plate[su]); c.addone(); c.Setrecord(su); plate[su].setBounds(finallyx+su*5,finallyy-su*plateHeight, bigestsize-10*su,plateHeight); &#125; &#125; public void hanoi(int n,Desk one,Desk two,Desk three) &#123; if(n==1) move(one,three); else &#123; hanoi(n-1,one,three,two); move(one,three); hanoi(n-1,two,one,three); &#125; &#125; public void move(Desk one, Desk two) &#123; //首先实现移动最顶端的盘子 //要做的事情包括修改相应的桌子上的盘子数，及下个盘子要放的位置，还有更新记录数组。 int num; //正在搬运的盘子的序号 double work; //取得盘子上的序号 //下面的工作是找到要移动的盘子的序号 int movewhich; movewhich=one.record[one.num-1]; //定制移动路线 //先向上运动到制高点 int x; int y; x=plate[movewhich].getX(); y=plate[movewhich].getY(); two.Settopx(movewhich); int stepleftright=(two.topx-x)/Math.abs(two.topx-x);//判断左移还是右移 while( y!=200) //向上升起 &#123; y=y-1; plate[movewhich].setLocation(x, y); try &#123; Thread.sleep(moveSpeed); &#125; catch (InterruptedException e) &#123; // TODO 自动生成 catch 块 e.printStackTrace(); &#125; &#125; //水平方向运动 while(x!=two.topx) //水平移动 &#123; x=x+stepleftright; plate[movewhich].setLocation(x, y); // this.repaint(); try &#123; Thread.sleep(moveSpeed); &#125; catch (InterruptedException e) &#123; // TODO 自动生成 catch 块 e.printStackTrace(); &#125; &#125; while(y!=two.topy) //向下落下 &#123; y=y+1; plate[movewhich].setLocation(x, y); try &#123; Thread.sleep(moveSpeed); &#125; catch (InterruptedException e) &#123; // TODO 自动生成 catch 块 e.printStackTrace(); &#125; &#125; one.DeleoneRecord(); //表示该盘子移走了 work=Double.parseDouble(plate[movewhich].getText()); num=(int)work; //System.out.print(num); one.subone(); //盘子数减少1 two.addone(); //盘子数加1 two.Setrecord(num); //桌子2上的记录数组添加1个元素 one.Settopxy(); //修改1座上 下个盘子的位置 two.Settopxy(); //修改2座上 下个盘子的位置 //设计函数实现下面的语句 String stringA=\"当前搬运动作为：\"+one.name.getText()+\"---&gt;\"+two.name.getText(); showAnswer.setText(stringA); steps++; String stringS=\"当前步数为：\"+steps; showStep.setText(stringS); &#125;&#125;class MainFrame extends Frame&#123; MenuBar menubar; Menu display,help,speed,num; MenuItem start,quit,paush,declare,introdue,speed0,speed1,speed2,speed3, num0,num1,num2,num3,num4; MenuActionRe replay=new MenuActionRe(); MainPanel mainpanel=new MainPanel(); MainFrame() &#123; &#125; MainFrame(String s) &#123; super(s); setTitle(s); menubar=new MenuBar(); display=new Menu(\"演示\"); help=new Menu(\"帮助\"); start=new MenuItem(\"开始\"); speed=new Menu(\"选择速度\"); num=new Menu(\"盘子数量\"); quit=new MenuItem(\"退出\"); quit.addActionListener( replay); paush=new MenuItem(\"暂停\"); declare=new MenuItem(\"说明\"); introdue=new MenuItem(\"介绍\"); speed0=new MenuItem(\"立即结束\"); speed1=new MenuItem(\"快速完成\"); speed2=new MenuItem(\"适中速度\"); speed3=new MenuItem(\"较慢实现\"); num0=new MenuItem(\"3\"); num0.addActionListener(replay); num1=new MenuItem(\"5\"); num1.addActionListener(replay); num2=new MenuItem(\"9\"); num2.addActionListener(replay); num3=new MenuItem(\"16\"); num3.addActionListener(replay); num4=new MenuItem(\"自定义\"); num4.addActionListener(replay); display.add(start); start.addActionListener(replay); display.add(speed); display.add(num); display.add(quit); speed.add(speed0); speed0.addActionListener(replay); speed.add(speed1); speed1.addActionListener(replay); speed.add(speed2); speed2.addActionListener(replay); speed.add(speed3); speed3.addActionListener(replay); num.add(num0); num.add(num1); num.add(num2); num.add(num3); num.add(num4); help.add(declare); declare.addActionListener(replay); help.add(introdue); introdue.addActionListener(replay); menubar.add(display); menubar.add(help); menubar.setFont(new Font(\"宋体\",Font.BOLD, 14)); setMenuBar(menubar); this.add(mainpanel,BorderLayout.CENTER); setVisible(true); setBounds(200,50,950,550); &#125; class MenuActionRe implements ActionListener &#123; public void actionPerformed(ActionEvent event) &#123; // TODO 自动生成方法存根 if(event.getSource()==quit) &#123; System.exit(0); //退出 &#125;else if(event.getSource()==start) &#123; if(mainpanel.a.num==0) &#123; //说明已经搬完了，是要重新开始啦 mainpanel.proplate(mainpanel.defaultnum); mainpanel.c.clear(); mainpanel.a.Settopxy(); mainpanel.b.Settopxy(); mainpanel.c.Settopxy(); &#125; if (mainpanel.moveSpeed == -1) &#123; mainpanel.hanoisoon(mainpanel.defaultnum); //立即结束 mainpanel.soonimg(mainpanel.defaultnum); String stringS=\"当前步数为：\"+mainpanel.steps; mainpanel.showStep.setText(stringS); String stringA=\"结束的太快，没来得及记录\"; mainpanel.showAnswer.setText(stringA); &#125; else mainpanel.hanoi(mainpanel.defaultnum, mainpanel.a,mainpanel.b, mainpanel.c); //mainpanel.showAnswer.setText(\"搬运结束,搬运次数为：\"+mainpanel.steps); &#125;else if(event.getSource()==declare) &#123; Help1 dialog=new Help1(); dialog.setVisible(true); &#125;else if(event.getSource()==introdue) &#123; Help2 dialog=new Help2(); dialog.setVisible(true); &#125;else if(event.getSource()==num0) &#123; mainpanel.ChangeDefault(3); mainpanel.proplate(mainpanel.defaultnum); &#125;else if(event.getSource()==num1) &#123; mainpanel.ChangeDefault(5); mainpanel.proplate(mainpanel.defaultnum); &#125;else if(event.getSource()==num2) &#123; mainpanel.ChangeDefault(9); mainpanel.proplate(mainpanel.defaultnum); &#125;else if(event.getSource()==num3) &#123; mainpanel.ChangeDefault(16); mainpanel.proplate(mainpanel.defaultnum); &#125;else if(event.getSource()==num4) &#123; String str=JOptionPane.showInputDialog(\"请输入汉诺塔层数。n&lt;=16\"); int n=(int)Float.parseFloat(str); if(!(n&gt;=1 &amp;&amp; n&lt;=16))&#123; JOptionPane.showMessageDialog(null,\"请输入汉诺塔层数不大于17的整数。\"); &#125;else&#123; mainpanel.ChangeDefault(n); mainpanel.proplate(mainpanel.defaultnum); &#125; &#125;else if(event.getSource()==speed0) &#123; //立即结束 mainpanel.moveSpeed=-1; mainpanel.showSpeeds(); &#125;else if(event.getSource()==speed1) &#123; //快速完成 mainpanel.moveSpeed=0; mainpanel.showSpeeds(); &#125;else if(event.getSource()==speed2) &#123; //适中速度 mainpanel.moveSpeed=2; mainpanel.showSpeeds(); &#125;else if(event.getSource()==speed3) &#123; //较慢实现 mainpanel.moveSpeed=5; mainpanel.showSpeeds(); &#125; &#125; &#125;&#125;class Help1 extends JDialog&#123; JPanel panel1 = new JPanel(); JLabel jLabel1 = new JLabel(\"&lt;html&gt;&lt;pre&gt; 作者： 张伟(长安大学） &lt;br&gt; 2017年4月12日&lt;/pre&gt;&lt;/html&gt;\"); JLabel jLabel2 = new JLabel(); GridLayout gridLayout1 = new GridLayout(); Help1() &#123; super(new MainFrame(),\"程序说明\",false); setBounds(400,150,360,260); setVisible(true); jLabel2.setText(\"&lt;html&gt;使用说明： &lt;br&gt;通过演示菜单来控制程序的运行,&lt;br&gt;可以选择不同的移动速度，&lt;br&gt;或者定制盘子的数量。&lt;html&gt;\"); panel1.add(jLabel1,BorderLayout.NORTH); panel1.add(jLabel2,BorderLayout.CENTER); setResizable(false); getContentPane().add(panel1); &#125; &#125;class Help2 extends JDialog&#123; JPanel panel1 = new JPanel(); JLabel jLabel2 = new JLabel(); GridLayout gridLayout1 = new GridLayout(); Help2() &#123; super(new MainFrame(),\"汉诺塔问题介绍\",false); setBounds(400,150,360,260); setVisible(true); jLabel2.setText(\"&lt;html&gt;汉诺塔问题： &lt;br&gt;有若干个大小各不相同的盘子,&lt;br&gt;有三个桌子A、B、C，开始时，&lt;br&gt;盘子全部位于A桌上，现要将&lt;br&gt;盘子从\" + \"A桌上移动到C桌上，&lt;br&gt;过程中要保证大盘子不能放到&lt;br&gt;小盘子上面,且每次只能移动一个盘子。&lt;html&gt;\"); panel1.add(jLabel2,BorderLayout.CENTER); getContentPane().add(panel1); &#125; &#125;public class HanoiDisply &#123; public static void main(String arg[]) &#123; MainFrame mainframe=new MainFrame(\"汉诺塔演示程序\"); mainframe.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); mainframe.setResizable(false); &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://yaris079.github.io/tags/算法/"}]},{"title":"如何写一篇hexo博客","date":"2017-04-04T23:35:38.000Z","path":"2017/04/05/how-to-write-a-hexo-artical/","text":"Hexo使用markdown语法的纯文本编辑，文件后缀名.md ,文件存放在：我们的站点目录下/source/_post 文件夹下 文件生成方式： hexo new layout 文件名 例：hexo new post HelloWorld 如果文件名中有空格必须给文件名加引号 hexo new post “Hello World” layout是可选的，默认为post,layout有哪些呢，我们可以到我们的站点目录下的scaffolds文件夹下查看也可以编辑现有的Layout文件 1234post:title:如何写一篇hexo博客date:1412081498000tags:- 有的时候我们想给自己写的blog分类就可以对post文件进行修改，修改后我们以后再写文章就不用再次添加了 1234title:如何写一篇hexo博客date:1412081498000categories:-tags:- 博客编辑完成之后在中端执行部署命令： hexo g 接下来我们可以使用markdown编辑器来编辑我们的博客文章了，我们可以直接在Finder里面找到/source/_post/下面新生成的 博客.md文件双击打开。 （注意：如果出现权限问题打不开博文，可以右击博文选择显示简介，在简介页面最下边把 权限更改为 读与写） markdown语法教程： 标题： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 列表 引用 在文本前面添加 &gt; 图片与链接 图片：![](图片地址)图片地址可以使本地图片路径，或者图片网址 网址：[]()yaris的个人博客 粗体与斜体 粗体：用两个*包含一段文本就是粗体。 例：**粗体**粗体 斜体：用一个*包含一段文本就是斜体 例：*斜体*斜体 表格 12345|Tables|Are|Cool||-------------|:-------------:|-----:||col 3 is|right-aligned|$1600||col 2 is|centered|$12||zebra stripes|are neat|$1| 生成的表格样式如下： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码框 只需要用两个 ` 把中间的代码包含起来 也可以使用tab键缩进4个空格 分割线 分割线的语法只需要加三个-号或*","tags":[{"name":"hexo","slug":"hexo","permalink":"https://yaris079.github.io/tags/hexo/"}]},{"title":"first blog","date":"2017-03-27T13:48:00.000Z","path":"2017/03/27/first-blog/","text":"这是一篇测试文章，欢迎关注作者博客: https://yaris079.github.io/","tags":[{"name":"随笔","slug":"随笔","permalink":"https://yaris079.github.io/tags/随笔/"}]}]
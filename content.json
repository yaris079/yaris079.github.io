[{"title":"Xilinx_arm交叉编译器安装","date":"2017-05-07T06:18:36.000Z","path":"2017/05/07/Xilinx-arm/","text":"1.下载交叉编译器首先下载官方制作好的交叉编译器http://xilinx.wikidot.com/zynq-tools，下载的文件为xilinx-2011.09-50-arm-xilinx-linux-gnueabi.bin 2.安装32位库64位的系统用户在安装GNU工具包时可能会遇到找不到依赖关系的问题，这是由于Ubuntu64位发行版少一些32位库。可以通过如下命令安装： 1apt-get install ia32-libs Ubuntu16.04已经不再支持这个源，可以使用以下操作安装。查看现有架构：1dpkg --print-architecture 你将会看到像下面这样的内容:1amd64 打开多架构支持，下载安装32位库：123dpkg--add-architecturei386apt-get updatesudo apt-get install libc6:i386 3.Xilinux ARM交叉编译器的安装 1） Xilinx提供的直接可用的交叉编译器xilinx-2011.09-50-arm-xilinx-linux-gnueabi.bin。接下来安装交叉编译器，指令如下：123chmod +x xilinx-2011.09-50-arm-xilinx-linux-gnueabi.bin //将其设置成可执行文件sudo dpkg-reconfigure -plow dash //这一步只为了修复/bin/sh指向dash而不是bash或其他支持的shell的错误。执行命令后，在出现的界面中，选择否./xilinx-2011.09-50-arm-xilinx-linux-gnueabi.bin //开始安装 在安装过程中，安装向导会给出选择“Add product to the PATH?”。若选择“Do not modify PATH.”，则需要在安装完成后手动添加环境变量，接下来会讲到。安装路径可以用默认路径，为 /root/CodeSourcery/Sourcery_CodeBench_Lite_for_Xilinx_GNU_Linux 2）安装完后，若需要手动添加环境变量，以后每次编译软件的时候都需要通过export指令将编译环境路径加入到PATH环境变量，在终端中输入命令如下：123export ARCH=armexport CROSS_COMPILE=arm-xilinx-linux-gnueabi-export PATH=/root/CodeSourcery/Sourcery_CodeBench_Lite_for_Xilinx_GNU_Linux/bin/:$PATH 若不想每次都输入，就在通过gedit /etc/bash.bashrc指令打开bash.bashrc文件，在里面加入上述指令，这样开机就会自动执行了。 至此，系统环境已搭成，可以通过如下命令来验证：1arm-xilinx-linux-gnueabi-gcc-v //打印版本命令。如果可以打印出交叉编译器的版本信息，则说明系统环境设置成功。 在最后一行会显示编译器的版本信息。","tags":[{"name":"嵌入式arm","slug":"嵌入式arm","permalink":"https://yaris079.github.io/tags/嵌入式arm/"}]},{"title":"Hello World","date":"2017-04-18T07:54:21.339Z","path":"2017/04/18/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"hanoi","date":"2017-04-13T01:58:29.000Z","path":"2017/04/13/hanoi/","text":"汉诺塔问题问题说明汉诺塔问题，就是把A柱子上面从大到小依次叠放的盘子借助B柱移到C柱上去，规则是一次只能移动一个盘子，大盘子不能放到小盘子之上。设有三个塔座A、B、C，n个圆盘。这些圆盘互不相同，初始时，这些编号为1,2，…，n的圆盘从大到小依次放在塔座A上。最底下为最大圆盘。要求将该塔座上的所有圆盘移到另一个塔座C上，并按照同样顺序放置。圆盘移动时，满足以下规则：①一次只能移动一个圆盘；②任何时刻不允许将大的圆盘放在小的圆盘之上；③圆盘可以放在A、B和C的任一塔座上。 思想：我们可以先通过塔座C将n-1个盘子移动到塔座B上，再将第n个盘子从塔座A移动到塔座C上，最后通过塔座A将n-1个盘子从塔座B移动到塔座C上。其中将n-1个盘子从塔座A移动到塔座B上可以视为将n个盘子从塔座A移动到塔座C上的一个子问题。采用递归的方法来解 1.先将塔座A上面的n-1个盘子，移动到塔座B上。 2.然后把塔座A上最大的一个盘子放到塔座C上去。 3.然后把塔座B上面的n-1个盘子移到塔座C上。 步骤：汉诺塔采用递归思想，首先考虑一种临界状态,把n-1个上面的盘从A–&gt;B, 就是把n从A移动到C,最后把n-1个盘从B–&gt;C（注意在考虑把n-1个盘从B—C的时候就出现递归调用，如果把A，B盘交换就又重复上面的流程了，最后到n = 1的时候就返回）。 伪代码： 123456HANOI(n, A, B, C) if n=1 then MOVE(A, 1, C) else HANOI(n-1, A, C, B) MOVE(A, n, C) HANOI(n-1, B, A, C) 界面 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549package hanoi;import java.awt.*;import javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;class Pillar extends JPanel&#123; Label pillar; Pillar() &#123; pillar = new Label(); pillar.setBackground(Color.black); pillar.setBounds(0, 0,4, 180); this.add(pillar); this.setSize(4, 180); //桌子面板大小 this.setLayout(null); &#125;&#125;class Desk extends JPanel //盘子&#123; Label topPanel,leftLeg,rightLeg,name; int num; // 桌子上现有盘子的数量 public int topy=340,topx=80; //第一个个盘子在哪里放下 int maxsize=16; //设置最大盘子数目 int initialx=0,initialy=340; int record[]=new int[16]; Desk(String s) //构造函数 &#123; name=new Label(); name.setText(s); //桌子名称 name.setBounds(70, 20,60, 30); topPanel=new Label(); //桌面 topPanel.setBackground(Color.red); topPanel.setBounds(0, 0,220, 10); this.setSize(220, 50); //桌子面板大小 this.setLayout(null); this.add(topPanel); this.add(name); this.setFont(new Font(\"宋体\",Font.CENTER_BASELINE, 16)); this.setForeground(Color.blue); this.setBackground(Color.WHITE); for (int i=0;i&lt;maxsize;i++) //记录型数组，记录该桌子上放的是哪些盘子，数组元素值为盘子下标。 &#123; record[i]=-1; &#125; &#125; public void Setrecord(int y) //修改记录数组 &#123; record[num-1]=y; //记录最上面的盘子的序号 &#125; public void DeleoneRecord() //当移走某个盘子时，置相应的数组值为-1 &#123; record[num-1]=-1; &#125; public void Setinitialxy(int x ) //修改下一个盘子的盘放位置 &#123; initialx=x; &#125; public void Settopxy() &#123; topx=initialx+num*5; topy=initialy-num*10; &#125; public void Settopx(int x) &#123; topx=initialx+x*5; &#125; public void clear() &#123; num=0; &#125; public void addone() &#123; this.num++; &#125; public void subone() &#123; this.num--; &#125;&#125;class MainPanel extends JPanel&#123; // Pillar pa,pb,pc; Desk a,b,c; int speed; //移动速度 int defaultnum=3; // 初始盘子数 boolean changnum; int maxsize=16; Label plate[]=new Label[maxsize]; int bigestsize=180; //最大盘子的尺寸 int plateHeight=10; int initialx=80; //a座 int initialy=340; int finallyx=680; //c座 int finallyy=340; int moveSpeed=0; //默认为快速完成 int steps=0; //完成步数 public TextField showSpeed=new TextField(\"速度显示区\"); public TextField showAnswer=new TextField(\"动作显示区\"); public TextField showStep=new TextField(\"步数显示区\"); MainPanel() &#123; for(int k=0;k&lt;maxsize;k++) &#123; plate[k]=new Label(); &#125; a=new Desk(\"A 座\"); b=new Desk(\"B 座\"); c=new Desk(\"C 座\"); this.add(a); this.add(b); this.add(c); a.setLocation(60, 350); b.setLocation(360,350); c.setLocation(660,350); pa=new Pillar(); pb=new Pillar(); pc=new Pillar(); this.add(pa); this.add(pb); this.add(pc); pa.setLocation(168, 170); pb.setLocation(468,170); pc.setLocation(768,170); this.add(showSpeed); this.add(showAnswer); this.add(showStep); showSpeed.setBounds(50, 50, 200, 25); showSpeed.setEditable(false); showSpeeds(); showAnswer.setBounds(300, 50, 200, 25); showAnswer.setEditable(false); showStep.setBounds(550, 50, 200, 25); showStep.setEditable(false); this.setBackground(Color.white); this.proplate(defaultnum); //初始化时产生的默认数量的盘子 this.setSize(950,550); this.setLayout(null); a.Setinitialxy(80); b.Setinitialxy(380); c.Setinitialxy(680); a.Settopxy(); b.Settopxy(); c.Settopxy(); changnum=false; validate(); &#125; public void ChangeDefault(int x) &#123; this.defaultnum=x; changnum=true; &#125; public void RemoveAllPlate() &#123; for(int i=0;i&lt;maxsize;i++) &#123; this.remove(plate[i]); &#125; &#125; public void showSpeeds() &#123; String sp; if (this.moveSpeed == -1) sp=\"当前速度为：立即结束\"; else if (this.moveSpeed == 0) sp=\"当前速度为：快速完成\"; else if (this.moveSpeed == 2) sp=\"当前速度为：适中速度\"; else sp=\"当前速度为：较慢实现\"; showSpeed.setText(sp); &#125; public void proplate(int sum) &#123; showAnswer.setText(\"动作显示区\"); showStep.setText(\"步数显示区\"); steps=0; if(changnum==true) &#123; this.RemoveAllPlate(); a.clear(); b.clear(); c.clear(); a.Settopxy(); b.Settopxy(); c.Settopxy(); &#125; for(int su=0;su&lt;sum;su++) //初始化A座 &#123; plate[su].setText(\" \"+su); plate[su].setBackground(Color.black); plate[su].setForeground(Color.red); plate[su].setVisible(true); this.add(plate[su]); a.addone(); //A盘子数加1 a.Setrecord(su); //修改桌子A的记录数组 plate[su].setBounds(initialx+su*5,initialy-su*plateHeight, bigestsize-10*su,plateHeight); &#125; &#125; public void hanoisoon(int n) //立即结束 &#123; /* if (n == 1) &#123; steps++; &#125; else &#123; hanoisoon(n - 1, one, three, two); steps++; hanoisoon(n - 1, two, one, three); &#125;*/ steps=(int)Math.pow(2, n)-1; c.num=n; &#125; public void soonimg(int n) &#123; //初始化三个塔座信息，在C座上画盘子 a.clear(); b.clear(); c.clear(); this.a.Settopxy(); this.b.Settopxy(); this.c.Settopxy(); for(int su=0;su&lt;n;su++) &#123; plate[su].setText(\" \"+su); plate[su].setBackground(Color.black); plate[su].setForeground(Color.red); plate[su].setVisible(true); this.add(plate[su]); c.addone(); c.Setrecord(su); plate[su].setBounds(finallyx+su*5,finallyy-su*plateHeight, bigestsize-10*su,plateHeight); &#125; &#125; public void hanoi(int n,Desk one,Desk two,Desk three) &#123; if(n==1) move(one,three); else &#123; hanoi(n-1,one,three,two); move(one,three); hanoi(n-1,two,one,three); &#125; &#125; public void move(Desk one, Desk two) &#123; //首先实现移动最顶端的盘子 //要做的事情包括修改相应的桌子上的盘子数，及下个盘子要放的位置，还有更新记录数组。 int num; //正在搬运的盘子的序号 double work; //取得盘子上的序号 //下面的工作是找到要移动的盘子的序号 int movewhich; movewhich=one.record[one.num-1]; //定制移动路线 //先向上运动到制高点 int x; int y; x=plate[movewhich].getX(); y=plate[movewhich].getY(); two.Settopx(movewhich); int stepleftright=(two.topx-x)/Math.abs(two.topx-x);//判断左移还是右移 while( y!=200) //向上升起 &#123; y=y-1; plate[movewhich].setLocation(x, y); try &#123; Thread.sleep(moveSpeed); &#125; catch (InterruptedException e) &#123; // TODO 自动生成 catch 块 e.printStackTrace(); &#125; &#125; //水平方向运动 while(x!=two.topx) //水平移动 &#123; x=x+stepleftright; plate[movewhich].setLocation(x, y); // this.repaint(); try &#123; Thread.sleep(moveSpeed); &#125; catch (InterruptedException e) &#123; // TODO 自动生成 catch 块 e.printStackTrace(); &#125; &#125; while(y!=two.topy) //向下落下 &#123; y=y+1; plate[movewhich].setLocation(x, y); try &#123; Thread.sleep(moveSpeed); &#125; catch (InterruptedException e) &#123; // TODO 自动生成 catch 块 e.printStackTrace(); &#125; &#125; one.DeleoneRecord(); //表示该盘子移走了 work=Double.parseDouble(plate[movewhich].getText()); num=(int)work; //System.out.print(num); one.subone(); //盘子数减少1 two.addone(); //盘子数加1 two.Setrecord(num); //桌子2上的记录数组添加1个元素 one.Settopxy(); //修改1座上 下个盘子的位置 two.Settopxy(); //修改2座上 下个盘子的位置 //设计函数实现下面的语句 String stringA=\"当前搬运动作为：\"+one.name.getText()+\"---&gt;\"+two.name.getText(); showAnswer.setText(stringA); steps++; String stringS=\"当前步数为：\"+steps; showStep.setText(stringS); &#125;&#125;class MainFrame extends Frame&#123; MenuBar menubar; Menu display,help,speed,num; MenuItem start,quit,paush,declare,introdue,speed0,speed1,speed2,speed3, num0,num1,num2,num3,num4; MenuActionRe replay=new MenuActionRe(); MainPanel mainpanel=new MainPanel(); MainFrame() &#123; &#125; MainFrame(String s) &#123; super(s); setTitle(s); menubar=new MenuBar(); display=new Menu(\"演示\"); help=new Menu(\"帮助\"); start=new MenuItem(\"开始\"); speed=new Menu(\"选择速度\"); num=new Menu(\"盘子数量\"); quit=new MenuItem(\"退出\"); quit.addActionListener( replay); paush=new MenuItem(\"暂停\"); declare=new MenuItem(\"说明\"); introdue=new MenuItem(\"介绍\"); speed0=new MenuItem(\"立即结束\"); speed1=new MenuItem(\"快速完成\"); speed2=new MenuItem(\"适中速度\"); speed3=new MenuItem(\"较慢实现\"); num0=new MenuItem(\"3\"); num0.addActionListener(replay); num1=new MenuItem(\"5\"); num1.addActionListener(replay); num2=new MenuItem(\"9\"); num2.addActionListener(replay); num3=new MenuItem(\"16\"); num3.addActionListener(replay); num4=new MenuItem(\"自定义\"); num4.addActionListener(replay); display.add(start); start.addActionListener(replay); display.add(speed); display.add(num); display.add(quit); speed.add(speed0); speed0.addActionListener(replay); speed.add(speed1); speed1.addActionListener(replay); speed.add(speed2); speed2.addActionListener(replay); speed.add(speed3); speed3.addActionListener(replay); num.add(num0); num.add(num1); num.add(num2); num.add(num3); num.add(num4); help.add(declare); declare.addActionListener(replay); help.add(introdue); introdue.addActionListener(replay); menubar.add(display); menubar.add(help); menubar.setFont(new Font(\"宋体\",Font.BOLD, 14)); setMenuBar(menubar); this.add(mainpanel,BorderLayout.CENTER); setVisible(true); setBounds(200,50,950,550); &#125; class MenuActionRe implements ActionListener &#123; public void actionPerformed(ActionEvent event) &#123; // TODO 自动生成方法存根 if(event.getSource()==quit) &#123; System.exit(0); //退出 &#125;else if(event.getSource()==start) &#123; if(mainpanel.a.num==0) &#123; //说明已经搬完了，是要重新开始啦 mainpanel.proplate(mainpanel.defaultnum); mainpanel.c.clear(); mainpanel.a.Settopxy(); mainpanel.b.Settopxy(); mainpanel.c.Settopxy(); &#125; if (mainpanel.moveSpeed == -1) &#123; mainpanel.hanoisoon(mainpanel.defaultnum); //立即结束 mainpanel.soonimg(mainpanel.defaultnum); String stringS=\"当前步数为：\"+mainpanel.steps; mainpanel.showStep.setText(stringS); String stringA=\"结束的太快，没来得及记录\"; mainpanel.showAnswer.setText(stringA); &#125; else mainpanel.hanoi(mainpanel.defaultnum, mainpanel.a,mainpanel.b, mainpanel.c); //mainpanel.showAnswer.setText(\"搬运结束,搬运次数为：\"+mainpanel.steps); &#125;else if(event.getSource()==declare) &#123; Help1 dialog=new Help1(); dialog.setVisible(true); &#125;else if(event.getSource()==introdue) &#123; Help2 dialog=new Help2(); dialog.setVisible(true); &#125;else if(event.getSource()==num0) &#123; mainpanel.ChangeDefault(3); mainpanel.proplate(mainpanel.defaultnum); &#125;else if(event.getSource()==num1) &#123; mainpanel.ChangeDefault(5); mainpanel.proplate(mainpanel.defaultnum); &#125;else if(event.getSource()==num2) &#123; mainpanel.ChangeDefault(9); mainpanel.proplate(mainpanel.defaultnum); &#125;else if(event.getSource()==num3) &#123; mainpanel.ChangeDefault(16); mainpanel.proplate(mainpanel.defaultnum); &#125;else if(event.getSource()==num4) &#123; String str=JOptionPane.showInputDialog(\"请输入汉诺塔层数。n&lt;=16\"); int n=(int)Float.parseFloat(str); if(!(n&gt;=1 &amp;&amp; n&lt;=16))&#123; JOptionPane.showMessageDialog(null,\"请输入汉诺塔层数不大于17的整数。\"); &#125;else&#123; mainpanel.ChangeDefault(n); mainpanel.proplate(mainpanel.defaultnum); &#125; &#125;else if(event.getSource()==speed0) &#123; //立即结束 mainpanel.moveSpeed=-1; mainpanel.showSpeeds(); &#125;else if(event.getSource()==speed1) &#123; //快速完成 mainpanel.moveSpeed=0; mainpanel.showSpeeds(); &#125;else if(event.getSource()==speed2) &#123; //适中速度 mainpanel.moveSpeed=2; mainpanel.showSpeeds(); &#125;else if(event.getSource()==speed3) &#123; //较慢实现 mainpanel.moveSpeed=5; mainpanel.showSpeeds(); &#125; &#125; &#125;&#125;class Help1 extends JDialog&#123; JPanel panel1 = new JPanel(); JLabel jLabel1 = new JLabel(\"&lt;html&gt;&lt;pre&gt; 作者： 张伟(长安大学） &lt;br&gt; 2017年4月12日&lt;/pre&gt;&lt;/html&gt;\"); JLabel jLabel2 = new JLabel(); GridLayout gridLayout1 = new GridLayout(); Help1() &#123; super(new MainFrame(),\"程序说明\",false); setBounds(400,150,360,260); setVisible(true); jLabel2.setText(\"&lt;html&gt;使用说明： &lt;br&gt;通过演示菜单来控制程序的运行,&lt;br&gt;可以选择不同的移动速度，&lt;br&gt;或者定制盘子的数量。&lt;html&gt;\"); panel1.add(jLabel1,BorderLayout.NORTH); panel1.add(jLabel2,BorderLayout.CENTER); setResizable(false); getContentPane().add(panel1); &#125; &#125;class Help2 extends JDialog&#123; JPanel panel1 = new JPanel(); JLabel jLabel2 = new JLabel(); GridLayout gridLayout1 = new GridLayout(); Help2() &#123; super(new MainFrame(),\"汉诺塔问题介绍\",false); setBounds(400,150,360,260); setVisible(true); jLabel2.setText(\"&lt;html&gt;汉诺塔问题： &lt;br&gt;有若干个大小各不相同的盘子,&lt;br&gt;有三个桌子A、B、C，开始时，&lt;br&gt;盘子全部位于A桌上，现要将&lt;br&gt;盘子从\" + \"A桌上移动到C桌上，&lt;br&gt;过程中要保证大盘子不能放到&lt;br&gt;小盘子上面,且每次只能移动一个盘子。&lt;html&gt;\"); panel1.add(jLabel2,BorderLayout.CENTER); getContentPane().add(panel1); &#125; &#125;public class HanoiDisply &#123; public static void main(String arg[]) &#123; MainFrame mainframe=new MainFrame(\"汉诺塔演示程序\"); mainframe.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); mainframe.setResizable(false); &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://yaris079.github.io/tags/算法/"}]},{"title":"如何写一篇hexo博客","date":"2017-04-04T23:35:38.000Z","path":"2017/04/05/how-to-write-a-hexo-artical/","text":"Hexo使用markdown语法的纯文本编辑，文件后缀名.md ,文件存放在：我们的站点目录下/source/_post 文件夹下 文件生成方式： hexo new layout 文件名 例：hexo new post HelloWorld 如果文件名中有空格必须给文件名加引号 hexo new post “Hello World” layout是可选的，默认为post,layout有哪些呢，我们可以到我们的站点目录下的scaffolds文件夹下查看也可以编辑现有的Layout文件 1234post:title:如何写一篇hexo博客date:1412081498000tags:- 有的时候我们想给自己写的blog分类就可以对post文件进行修改，修改后我们以后再写文章就不用再次添加了 1234title:如何写一篇hexo博客date:1412081498000categories:-tags:- 博客编辑完成之后在中端执行部署命令： hexod-g 接下来我们可以使用markdown编辑器来编辑我们的博客文章了，我们可以直接在Finder里面找到/source/_post/下面新生成的 博客.md文件双击打开。 （注意：如果出现权限问题打不开博文，可以右击博文选择显示简介，在简介页面最下边把 权限更改为 读与写） markdown语法教程： 标题： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 列表 引用 在文本前面添加 &gt; 图片与链接 图片：![](图片地址)图片地址可以使本地图片路径，或者图片网址 网址：[]()yaris的个人博客 粗体与斜体 粗体：用两个包含一段文本就是粗体。 例：*粗体 斜体：用一个*包含一段文本就是斜体 表格 |Tables|Are|Cool||-------------|:-------------:|-----:||col 3 is|right-aligned|$1600||col 2 is|centered|$12||zebra stripes|are neat|$1| 生成的表格样式如下： TablesAreCool col 3 isright-aligned$1600 col 2 iscentered$12 zebra stripesare neat$1 代码框 只需要用两个 ` 把中间的代码包含起来 也可以使用tab键缩进4个空格 分割线 分割线的语法只需要加三个-号或*","tags":[{"name":"hexo","slug":"hexo","permalink":"https://yaris079.github.io/tags/hexo/"}]},{"title":"first blog","date":"2017-03-27T13:48:00.000Z","path":"2017/03/27/first-blog/","text":"这是一篇测试文章，欢迎关注作者博客: https://yaris079.github.io/","tags":[{"name":"随笔","slug":"随笔","permalink":"https://yaris079.github.io/tags/随笔/"}]}]